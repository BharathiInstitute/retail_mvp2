From 225ee36eceaf331e22f580378b5b94de6ef2e338 Mon Sep 17 00:00:00 2001
From: jyo <bharathiinstitute1@gmail.com>
Date: Thu, 9 Oct 2025 15:46:40 +0530
Subject: [PATCH 1/5] POS: silent web printing pipeline + Windows silent
 fallback; backend server hardened; credit service (add/repay/mixed)
 transactional; cashier screen; print settings UI. Also: config default
 printer, safe enums, and cleanup of legacy demo.

---
 .vscode/tasks.json                            |   6 +
 firestore.rules                               | 101 ++
 lib/app_shell.dart                            |  26 +-
 lib/modules/crm/crm.dart                      |  84 +-
 lib/modules/inventory/alerts_screen.dart      |  12 +-
 .../inventory/inventory_repository.dart       |   8 +-
 .../inventory/inventory_sheet_page.dart       |  11 +-
 .../inventory/stock_movements_screen.dart     |   9 +-
 lib/modules/inventory/transfers_screen.dart   |   9 +-
 lib/modules/pos/backend_launcher_desktop.dart |  51 +
 lib/modules/pos/backend_launcher_stub.dart    |   2 +
 lib/modules/pos/credit_service.dart           | 346 +++++++
 lib/modules/pos/pos.dart                      | 140 ++-
 lib/modules/pos/pos_cashier.dart              | 487 ++++++++++
 lib/modules/pos/pos_checkout.dart             | 869 +++++++++++-------
 lib/modules/pos/pos_ui.dart                   | 673 ++++++++++----
 lib/modules/pos/print_settings.dart           |  61 +-
 lib/modules/pos/print_settings_dialog.dart    | 167 ++++
 lib/modules/pos/web_print_fallback.dart       | 168 ++++
 lib/modules/pos/web_print_fallback_stub.dart  |  12 +
 lib/modules/pos/windows_print.dart            | 142 +++
 lib/modules/pos/windows_print_stub.dart       |   9 +
 lib/modules/printing_demo/print_demo.dart     | 117 +--
 printer_backend/config.json                   |   8 +-
 printer_backend/package-lock.json             | 836 ++++++++++++++++-
 printer_backend/package.json                  |  11 +-
 printer_backend/server.js                     | 456 ++++++++-
 27 files changed, 4108 insertions(+), 713 deletions(-)
 create mode 100644 lib/modules/pos/backend_launcher_desktop.dart
 create mode 100644 lib/modules/pos/backend_launcher_stub.dart
 create mode 100644 lib/modules/pos/credit_service.dart
 create mode 100644 lib/modules/pos/pos_cashier.dart
 create mode 100644 lib/modules/pos/print_settings_dialog.dart
 create mode 100644 lib/modules/pos/web_print_fallback.dart
 create mode 100644 lib/modules/pos/web_print_fallback_stub.dart
 create mode 100644 lib/modules/pos/windows_print.dart
 create mode 100644 lib/modules/pos/windows_print_stub.dart

diff --git a/.vscode/tasks.json b/.vscode/tasks.json
index a9fafed..32647d1 100644
--- a/.vscode/tasks.json
+++ b/.vscode/tasks.json
@@ -27,6 +27,12 @@
 			"type": "shell",
 			"command": "flutter analyze",
 			"group": "build"
+		},
+		{
+			"label": "Analyze before git push",
+			"type": "shell",
+			"command": "flutter analyze",
+			"group": "build"
 		}
 	]
 }
\ No newline at end of file
diff --git a/firestore.rules b/firestore.rules
index 8b13789..e70df49 100644
--- a/firestore.rules
+++ b/firestore.rules
@@ -1 +1,102 @@
 
+rules_version = '2';
+service cloud.firestore {
+	match /databases/{database}/documents {
+
+		// Helper: user signed in
+		function isSignedIn() {
+			return request.auth != null;
+		}
+
+		// Helper: for multi-tenant setups where each product has a tenantId field.
+		// Adjust or remove if you don't use tenant separation.
+		function tenantMatchesCreate() {
+			return isSignedIn() &&
+				(request.resource.data.keys().hasOnly(['tenantId','sku','barcode','name','description','unitPrice','mrpPrice','costPrice','taxPct','variants','categoryId','supplierId','isActive','batches']) || true) &&
+				request.resource.data.tenantId == request.auth.token.tenantId;
+		}
+		function tenantMatchesUpdate() {
+			return isSignedIn() &&
+				resource.data.tenantId == request.auth.token.tenantId &&
+				request.resource.data.tenantId == resource.data.tenantId; // cannot change tenantId
+		}
+
+		// Products (inventory) collection
+		match /inventory/{sku} {
+			// Open read access so POS & anonymous sessions can list products.
+			allow get, list: if true;
+
+			// Writes still restricted to authenticated tenant (adjust if you don't use tenant claims)
+			allow create: if tenantMatchesCreate();
+			allow update, delete: if tenantMatchesUpdate();
+		}
+
+		// (Optional) Allow reads on needed supporting collections (customers, etc.)
+		// Customers collection & nested credit ledger
+		match /customers/{id} {
+			// Reads allowed to signed-in users (or open if you want POS kiosk access without auth)
+			allow get, list: if isSignedIn();
+			// Create minimal customer
+			allow create: if isSignedIn();
+			// Restrict updates to allowed known fields only (prevents arbitrary field injection)
+			function validCustomerUpdate() {
+				// Only restrict the CHANGED keys, not the entire document key set.
+				return request.resource.data.diff(resource.data).changedKeys().hasOnly([
+					'name','email','phone','address','status','loyaltyDiscount','loyaltyPoints','loyaltyUpdatedAt',
+					'lastInvoiceNumber','lastInvoiceTotal','loyaltyEarnedLast','loyaltyRedeemedLast','totalSpend',
+					'creditBalance','creditUpdatedAt','createdAt','tenantId'
+				]);
+			}
+			// Allow a very restricted unauthenticated credit balance delta (kiosk mode) – OPTIONAL.
+			function isSimpleCreditDelta() {
+				return request.auth == null &&
+				  request.resource.data.diff(resource.data).changedKeys().hasOnly(['creditBalance','creditUpdatedAt']) &&
+				  (request.resource.data.creditBalance is number);
+			}
+			allow update: if (isSignedIn() && validCustomerUpdate()) || isSimpleCreditDelta();
+			allow delete: if false; // block deletes (adjust if needed)
+
+			// Nested credit ledger entries: append-only create, readable for signed-in users
+			match /credit_ledger/{entry} {
+				function validLedgerCreate() {
+					return request.resource.data.keys().hasOnly(['type','amount','balanceAfter','invoiceNumber','timestamp'])
+						&& request.resource.data.type in ['add_sale','repayment']
+						&& (request.resource.data.amount is number)
+						&& (request.resource.data.balanceAfter is number);
+				}
+				allow get, list: if isSignedIn();
+				allow create: if isSignedIn() && validLedgerCreate();
+				allow update, delete: if false; // immutable ledger
+			}
+		}
+
+		// Invoices collection: create only (immutable after write except server processes)
+		match /invoices/{invoiceId} {
+			function validInvoiceCreate() {
+				return request.resource.data.keys().hasAll(['invoiceNumber','customerName','subtotal','grandTotal','status'])
+					&& (request.resource.data.grandTotal is number)
+					&& (request.resource.data.subtotal is number)
+					&& (request.resource.data.status in ['Paid','on_credit']);
+			}
+			allow get, list: if isSignedIn();
+			allow create: if isSignedIn() && validInvoiceCreate();
+			allow update: if false; // prevent tampering client-side
+			allow delete: if false;
+		}
+
+		// Settings documents (e.g. loyalty_config) – needed for loyalty points calculation
+		match /settings/{id} {
+			// Allow read of loyalty configuration to authenticated POS sessions
+			allow get, list: if isSignedIn();
+			// Only authenticated sessions can create/update settings (e.g., from admin panel)
+			allow create, update: if isSignedIn();
+			allow delete: if false; // safeguard
+		}
+
+		// Fallback deny all other access
+		match /{document=**} {
+			allow read, write: if false;
+		}
+	}
+}
+
diff --git a/lib/app_shell.dart b/lib/app_shell.dart
index 9330eb6..7bd26d6 100644
--- a/lib/app_shell.dart
+++ b/lib/app_shell.dart
@@ -7,6 +7,7 @@ import 'core/auth/auth.dart';
 // Module screens used by the router
 import 'modules/dashboard/dashboard.dart';
 import 'modules/pos/pos_ui.dart';
+import 'modules/pos/pos_cashier.dart';
 import 'modules/inventory/inventory.dart';
 import 'modules/invoices/invoices.dart';
 import 'modules/crm/crm.dart';
@@ -249,6 +250,19 @@ class AppShell extends ConsumerWidget {
         actions: [
           IconButton(onPressed: () {}, icon: const Icon(Icons.search)),
           IconButton(onPressed: () {}, icon: const Icon(Icons.brightness_6)),
+          // Cashier icon placed beside theme toggle as requested
+          Tooltip(
+            message: 'Cashier',
+            child: IconButton(
+              icon: const Icon(Icons.account_circle_outlined),
+              onPressed: () {
+                // Open cashier screen on top of current route stack
+                Navigator.of(context).push(
+                  MaterialPageRoute(builder: (_) => const PosCashierScreen()),
+                );
+              },
+            ),
+          ),
           if (user != null)
             PopupMenuButton<String>(
               itemBuilder: (context) => [
@@ -262,8 +276,9 @@ class AppShell extends ConsumerWidget {
               ],
               onSelected: (v) async {
                 if (v == 'signout') {
+                  final routerCtx = context; // capture before async gap
                   await ref.read(authRepositoryProvider).signOut();
-                  if (context.mounted) context.go('/login');
+                  if (routerCtx.mounted) routerCtx.go('/login');
                 }
               },
               icon: const Icon(Icons.person_outline),
@@ -287,9 +302,12 @@ class AppShell extends ConsumerWidget {
                         leading: Icon(e.icon),
                         title: Text(e.label),
                         selected: navigationShell.currentIndex == e.branchIndex,
-                        onTap: () {
-                          Navigator.of(context).pop();
-                          _goBranch(context, e.branchIndex);
+                        onTap: () async {
+                          final tapCtx = context; // capture before async gap
+                          // Avoid popping the last page off the GoRouter stack.
+                          await Navigator.of(tapCtx).maybePop();
+                          if (!tapCtx.mounted) return;
+                          _goBranch(tapCtx, e.branchIndex);
                         },
                       ),
                   ],
diff --git a/lib/modules/crm/crm.dart b/lib/modules/crm/crm.dart
index 5c3f620..3db0fc5 100644
--- a/lib/modules/crm/crm.dart
+++ b/lib/modules/crm/crm.dart
@@ -89,27 +89,60 @@ class _CrmListScreenState extends State<CrmListScreen> {
 
 	Future<void> _deleteCustomer(CrmCustomer c) async {
 		if (!mounted) return;
+		bool deleting = false;
 		final confirm = await showDialog<bool>(
 			context: context,
-			builder: (_) => AlertDialog(
-				title: const Text('Delete Customer'),
-				content: Text('Are you sure you want to delete "${c.name}"?'),
-				actions: [
-					TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Cancel')),
-					FilledButton.tonal(onPressed: () => Navigator.pop(context, true), child: const Text('Delete')),
-				],
+			barrierDismissible: !deleting,
+			builder: (dialogCtx) => StatefulBuilder(
+				builder: (dialogCtx, setLocal) {
+						return PopScope(
+							canPop: !deleting,
+							onPopInvoked: (didPop) {},
+							child: AlertDialog(
+							title: const Text('Delete Customer'),
+							content: Column(
+								mainAxisSize: MainAxisSize.min,
+								children: [
+									Text('Are you sure you want to delete "${c.name}"?'),
+									if (deleting) const Padding(padding: EdgeInsets.only(top:12), child: LinearProgressIndicator(minHeight: 3)),
+								],
+							),
+							actions: [
+								TextButton(onPressed: deleting ? null : () => Navigator.pop(dialogCtx, false), child: const Text('Cancel')),
+								FilledButton.tonal(
+									onPressed: deleting ? null : () async {
+										setLocal(() => deleting = true);
+										try {
+											// Ensure we are authenticated (anonymous if necessary) so rules allow delete.
+											final auth = FirebaseAuth.instance;
+											if (auth.currentUser == null) { await auth.signInAnonymously(); }
+											if (c.id.isEmpty) { throw Exception('Missing document id'); }
+											await FirebaseFirestore.instance.collection('customers').doc(c.id).delete();
+											if (context.mounted) {
+												Navigator.pop(dialogCtx, true);
+											}
+										} catch (e) {
+											if (context.mounted) {
+												ScaffoldMessenger.of(context).showSnackBar(
+													SnackBar(content: Text(e.toString().contains('permission-denied')
+														? 'Permission denied deleting customer.'
+														: 'Delete failed: $e')),
+												);
+											}
+										} finally {
+											if (dialogCtx.mounted) setLocal(() => deleting = false);
+										}
+									},
+									child: deleting ? const SizedBox(width:18,height:18,child:CircularProgressIndicator(strokeWidth:2)) : const Text('Delete'),
+								),
+							],
+						),
+					);
+				},
 			),
 		);
-		if (confirm != true) return;
-		try {
-			if (c.id.isEmpty) throw Exception('Missing document id');
-			await FirebaseFirestore.instance.collection('customers').doc(c.id).delete();
-			if (!mounted) return;
+		if (confirm == true && mounted) {
 			ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Deleted ${c.name}')));
-		} catch (e) {
-			if (!mounted) return;
-			ScaffoldMessenger.of(context)
-					.showSnackBar(SnackBar(content: Text('Failed to delete: $e')));
 		}
 	}
 
@@ -370,7 +403,6 @@ class _EditCustomerFormState extends State<_EditCustomerForm> {
 	late final TextEditingController nameCtrl;
 	late final TextEditingController phoneCtrl;
 	late final TextEditingController emailCtrl;
-	late LoyaltyStatus status;
 	bool _saving = false;
 
 	@override
@@ -380,7 +412,6 @@ class _EditCustomerFormState extends State<_EditCustomerForm> {
 		nameCtrl = TextEditingController(text: c.name);
 		phoneCtrl = TextEditingController(text: c.phone);
 		emailCtrl = TextEditingController(text: c.email);
-		status = c.status;
 	}
 
 	@override
@@ -407,7 +438,7 @@ class _EditCustomerFormState extends State<_EditCustomerForm> {
 				'name': nameCtrl.text.trim(),
 				'phone': phoneCtrl.text.trim(),
 				'email': emailCtrl.text.trim(),
-				'status': status.name,
+				// Loyalty status intentionally not editable here; keep existing value.
 				'updatedAt': FieldValue.serverTimestamp(),
 				if (id == null) 'createdAt': FieldValue.serverTimestamp(),
 			}, SetOptions(merge: true));
@@ -417,7 +448,7 @@ class _EditCustomerFormState extends State<_EditCustomerForm> {
 				name: nameCtrl.text.trim(),
 				phone: phoneCtrl.text.trim(),
 				email: emailCtrl.text.trim(),
-				status: status,
+				// status unchanged
 			);
 			if (mounted) Navigator.pop(context, updated);
 		} catch (e) {
@@ -460,15 +491,10 @@ class _EditCustomerFormState extends State<_EditCustomerForm> {
 							validator: (v) => (v == null || v.trim().isEmpty) ? 'Enter email' : null,
 						),
 						const SizedBox(height: 8),
-						DropdownButtonFormField<LoyaltyStatus>(
-							value: status,
-							items: const [
-								DropdownMenuItem(value: LoyaltyStatus.bronze, child: Text('Bronze')),
-								DropdownMenuItem(value: LoyaltyStatus.silver, child: Text('Silver')),
-								DropdownMenuItem(value: LoyaltyStatus.gold, child: Text('Gold')),
-							],
-							onChanged: (v) => setState(() => status = v ?? status),
-							decoration: const InputDecoration(labelText: 'Loyalty'),
+						// Loyalty status display (read-only)
+						Align(
+							alignment: Alignment.centerLeft,
+							child: Text('Loyalty: ${widget.customer.status.label}', style: const TextStyle(fontSize: 13, fontStyle: FontStyle.italic)),
 						),
 						const SizedBox(height: 12),
 						Row(
diff --git a/lib/modules/inventory/alerts_screen.dart b/lib/modules/inventory/alerts_screen.dart
index e678bac..fbc83eb 100644
--- a/lib/modules/inventory/alerts_screen.dart
+++ b/lib/modules/inventory/alerts_screen.dart
@@ -141,7 +141,7 @@ class _AlertsScreenState extends ConsumerState<AlertsScreen> {
               label: const Text('Low Stock'),
               selected: _showLowStock,
               onSelected: (v) => setState(() => _showLowStock = v),
-              selectedColor: _flagColor('Low Stock').withOpacity(.15),
+              selectedColor: _flagColor('Low Stock').withValues(alpha: 0.15),
               checkmarkColor: _flagColor('Low Stock'),
               avatar: Icon(Icons.inventory_2, size: 16, color: _flagColor('Low Stock')),
             ),
@@ -149,7 +149,7 @@ class _AlertsScreenState extends ConsumerState<AlertsScreen> {
               label: const Text('Expired'),
               selected: _showExpired,
               onSelected: (v) => setState(() => _showExpired = v),
-              selectedColor: _flagColor('Expired').withOpacity(.15),
+              selectedColor: _flagColor('Expired').withValues(alpha: 0.15),
               checkmarkColor: _flagColor('Expired'),
               avatar: Icon(Icons.warning_amber_rounded, size: 16, color: _flagColor('Expired')),
             ),
@@ -157,7 +157,7 @@ class _AlertsScreenState extends ConsumerState<AlertsScreen> {
               label: const Text('Expiring Soon'),
               selected: _showSoon,
               onSelected: (v) => setState(() => _showSoon = v),
-              selectedColor: _flagColor('Expiring Soon').withOpacity(.15),
+              selectedColor: _flagColor('Expiring Soon').withValues(alpha: 0.15),
               checkmarkColor: _flagColor('Expiring Soon'),
               avatar: Icon(Icons.schedule, size: 16, color: _flagColor('Expiring Soon')),
             ),
@@ -165,7 +165,7 @@ class _AlertsScreenState extends ConsumerState<AlertsScreen> {
               label: const Text('Expiry Warning'),
               selected: _showWarn,
               onSelected: (v) => setState(() => _showWarn = v),
-              selectedColor: _flagColor('Expiry Warning').withOpacity(.15),
+              selectedColor: _flagColor('Expiry Warning').withValues(alpha: 0.15),
               checkmarkColor: _flagColor('Expiry Warning'),
               avatar: Icon(Icons.timelapse, size: 16, color: _flagColor('Expiry Warning')),
             ),
@@ -210,9 +210,9 @@ class _AlertsScreenState extends ConsumerState<AlertsScreen> {
                               Chip(
                                 label: Text(f, style: const TextStyle(fontSize: 11, fontWeight: FontWeight.w500)),
                                 visualDensity: VisualDensity.compact,
-                                backgroundColor: _flagColor(f).withOpacity(.12),
+                                backgroundColor: _flagColor(f).withValues(alpha: 0.12),
                                 padding: const EdgeInsets.symmetric(horizontal: 6),
-                                side: BorderSide(color: _flagColor(f).withOpacity(.5), width: .6),
+                                side: BorderSide(color: _flagColor(f).withValues(alpha: 0.5), width: .6),
                                 materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                               ),
                           ])),
diff --git a/lib/modules/inventory/inventory_repository.dart b/lib/modules/inventory/inventory_repository.dart
index 341f9bd..5d5efa7 100644
--- a/lib/modules/inventory/inventory_repository.dart
+++ b/lib/modules/inventory/inventory_repository.dart
@@ -393,7 +393,7 @@ class ProductDoc {
             .whereType<BatchDoc>()
             .toList() ??
         const <BatchDoc>[];
-    double _toDouble(dynamic v) {
+    double toDoubleLocal(dynamic v) {
       if (v == null) return 0.0;
       if (v is double) return v;
       if (v is int) return v.toDouble();
@@ -406,9 +406,9 @@ class ProductDoc {
       barcode: (m['barcode'] ?? '') as String,
       name: (m['name'] ?? '') as String,
       description: m['description'] as String?,
-      unitPrice: _toDouble(m['unitPrice']),
-      mrpPrice: m['mrpPrice'] == null ? null : _toDouble(m['mrpPrice']),
-      costPrice: m['costPrice'] == null ? null : _toDouble(m['costPrice']),
+  unitPrice: toDoubleLocal(m['unitPrice']),
+  mrpPrice: m['mrpPrice'] == null ? null : toDoubleLocal(m['mrpPrice']),
+  costPrice: m['costPrice'] == null ? null : toDoubleLocal(m['costPrice']),
       taxPct: m['taxPct'] as num?,
       variants: (m['variants'] as List?)?.map((e) => e.toString()).toList() ?? const <String>[],
       categoryId: m['categoryId'] as String?,
diff --git a/lib/modules/inventory/inventory_sheet_page.dart b/lib/modules/inventory/inventory_sheet_page.dart
index 0457c0d..54f5bcb 100644
--- a/lib/modules/inventory/inventory_sheet_page.dart
+++ b/lib/modules/inventory/inventory_sheet_page.dart
@@ -192,8 +192,9 @@ class _InventorySheetPageState extends ConsumerState<InventorySheetPage> {
       final repo = ref.read(inventoryRepoProvider);
       final tenantFallback = existingBySku.values.isEmpty ? user.uid : existingBySku.values.first.tenantId;
 
+      final rootContext = context;
       await showDialog(
-        context: context,
+        context: rootContext,
         barrierDismissible: false,
         builder: (dialogCtx) {
           // Kick off async processing after first frame
@@ -287,14 +288,16 @@ class _InventorySheetPageState extends ConsumerState<InventorySheetPage> {
       );
 
       if (!mounted) return;
+      final messenger = ScaffoldMessenger.of(rootContext);
       if (processed == totalOps) {
-        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Upload complete')));
+        messenger.showSnackBar(const SnackBar(content: Text('Upload complete')));
       } else {
-        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Upload incomplete ($processed/$totalOps). See log.')));
+        messenger.showSnackBar(SnackBar(content: Text('Upload incomplete ($processed/$totalOps). See log.')));
       }
     } catch (e) {
       if (mounted) {
-        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Upload failed: $e')));
+        final messenger = ScaffoldMessenger.of(context);
+        messenger.showSnackBar(SnackBar(content: Text('Upload failed: $e')));
       }
     } finally {
       if (mounted) setState(() => _uploading = false);
diff --git a/lib/modules/inventory/stock_movements_screen.dart b/lib/modules/inventory/stock_movements_screen.dart
index dac8f4d..46b5458 100644
--- a/lib/modules/inventory/stock_movements_screen.dart
+++ b/lib/modules/inventory/stock_movements_screen.dart
@@ -152,9 +152,9 @@ final _movementsProvider = StreamProvider.autoDispose<List<MovementRecord>>((ref
 
 MovementRecord _movementFromDoc(QueryDocumentSnapshot<Map<String, dynamic>> d) {
   final m = d.data();
-  DateTime? _ts(dynamic v) => v is Timestamp ? v.toDate() : null;
+  DateTime? tsLocal(dynamic v) => v is Timestamp ? v.toDate() : null;
   return MovementRecord(
-    date: _ts(m['createdAt']) ?? DateTime.fromMillisecondsSinceEpoch(0),
+    date: tsLocal(m['createdAt']) ?? DateTime.fromMillisecondsSinceEpoch(0),
     type: (m['type'] ?? '') as String,
     sku: (m['sku'] ?? '') as String,
     name: (m['name'] ?? '') as String,
@@ -164,7 +164,7 @@ MovementRecord _movementFromDoc(QueryDocumentSnapshot<Map<String, dynamic>> d) {
     warehouseAfter: (m['warehouseAfter'] as num?)?.toInt(),
     totalAfter: (m['totalAfter'] as num?)?.toInt(),
     note: m['note'] as String?,
-    updatedAt: _ts(m['updatedAt']),
+    updatedAt: tsLocal(m['updatedAt']),
     updatedBy: m['updatedBy'] as String?,
   );
 }
@@ -395,7 +395,8 @@ class _MovementDialogState extends ConsumerState<_MovementDialog> {
               updatedBy: after?.updatedBy,
             );
             if (mounted) {
-              Navigator.pop(context, record);
+              final nav = Navigator.of(context);
+              if (nav.mounted) nav.pop(record);
             }
           },
           child: _submitting
diff --git a/lib/modules/inventory/transfers_screen.dart b/lib/modules/inventory/transfers_screen.dart
index 0d68b47..9a5b161 100644
--- a/lib/modules/inventory/transfers_screen.dart
+++ b/lib/modules/inventory/transfers_screen.dart
@@ -161,9 +161,9 @@ final _transfersProvider = StreamProvider.autoDispose<List<TransferRecord>>((ref
 
 TransferRecord _transferFromDoc(QueryDocumentSnapshot<Map<String, dynamic>> d) {
   final m = d.data();
-  DateTime? _ts(dynamic v) => v is Timestamp ? v.toDate() : null;
+  DateTime? tsLocal(dynamic v) => v is Timestamp ? v.toDate() : null;
   return TransferRecord(
-    date: _ts(m['createdAt']) ?? DateTime.fromMillisecondsSinceEpoch(0),
+    date: tsLocal(m['createdAt']) ?? DateTime.fromMillisecondsSinceEpoch(0),
     sku: (m['sku'] ?? '') as String,
     name: (m['name'] ?? '') as String,
     from: (m['from'] ?? '') as String,
@@ -173,7 +173,7 @@ TransferRecord _transferFromDoc(QueryDocumentSnapshot<Map<String, dynamic>> d) {
     storeAfter: (m['storeAfter'] as num?)?.toInt(),
     warehouseAfter: (m['warehouseAfter'] as num?)?.toInt(),
     totalAfter: (m['totalAfter'] as num?)?.toInt(),
-    updatedAt: _ts(m['updatedAt']),
+    updatedAt: tsLocal(m['updatedAt']),
     updatedBy: m['updatedBy'] as String?,
   );
 }
@@ -387,7 +387,8 @@ class _TransferDialogState extends ConsumerState<_TransferDialog> {
                     return;
                   }
                   if (mounted) {
-                    Navigator.pop(context); // stream refresh
+                    final nav = Navigator.of(context);
+                    if (nav.mounted) nav.pop(); // stream refresh
                   }
                 },
           child: _submitting
diff --git a/lib/modules/pos/backend_launcher_desktop.dart b/lib/modules/pos/backend_launcher_desktop.dart
new file mode 100644
index 0000000..61c6949
--- /dev/null
+++ b/lib/modules/pos/backend_launcher_desktop.dart
@@ -0,0 +1,51 @@
+import 'dart:io';
+import 'dart:async';
+
+/// Attempts to start the local printer backend when running on Windows desktop if it's not reachable.
+/// The Node process is launched via a temporary VBScript (wscript.exe) with window style hidden
+/// so no PowerShell / console window flashes in front of the POS UI.
+Future<void> ensurePrinterBackendRunning({String host = 'localhost', int port = 5005}) async {
+  if (!Platform.isWindows) return;
+  final reachable = await _isReachable(host, port, timeout: const Duration(milliseconds: 700));
+  if (reachable) return; // already running
+
+  // Locate backend directory (development assumption: alongside the executable / project root)
+  final execDir = Directory.current;
+  final backendDir = Directory('${execDir.path}\\printer_backend');
+  if (!backendDir.existsSync()) return;
+  final serverFile = File('${backendDir.path}\\server.js');
+  if (!serverFile.existsSync()) return;
+
+  try {
+    // Build a temporary VBScript that runs: node server.js (hidden, not blocking)
+    final tmpDir = Directory.systemTemp;
+    final vbsFile = File('${tmpDir.path}\\launch_printer_backend_${DateTime.now().millisecondsSinceEpoch}.vbs');
+    final nodeCmd = 'node'; // rely on PATH. If needed, user can adjust PATH or install Node.
+    // Escape quotes for VBScript. We change working directory inside script to backendDir.
+    final escapedPath = backendDir.path.replaceAll('"', '""');
+    final script = [
+      'Set sh = CreateObject("WScript.Shell")',
+  'sh.CurrentDirectory = "$escapedPath"',
+      // 0 = hidden window, False = do not wait
+      'sh.Run """$nodeCmd"" ""server.js""", 0, False'
+    ].join('\r\n');
+    await vbsFile.writeAsString(script);
+
+    // Launch the VBScript using wscript (not cscript) so it is detached & hidden.
+    await Process.start('wscript.exe', [vbsFile.path], mode: ProcessStartMode.detached);
+    // Leave the temp file; OS will clean temp eventually. We could schedule deletion but that
+    // risks removing it before process spawn on very slow disks. Keeping is simplest.
+  } catch (_) {
+    // Swallow any failure; user can manually start backend.
+  }
+}
+
+Future<bool> _isReachable(String host, int port, {Duration timeout = const Duration(milliseconds: 600)}) async {
+  try {
+    final socket = await Socket.connect(host, port, timeout: timeout);
+    socket.destroy();
+    return true;
+  } catch (_) {
+    return false;
+  }
+}
diff --git a/lib/modules/pos/backend_launcher_stub.dart b/lib/modules/pos/backend_launcher_stub.dart
new file mode 100644
index 0000000..c8d6119
--- /dev/null
+++ b/lib/modules/pos/backend_launcher_stub.dart
@@ -0,0 +1,2 @@
+/// No-op backend launcher for non-IO platforms (web).
+Future<void> ensurePrinterBackendRunning() async {}
diff --git a/lib/modules/pos/credit_service.dart b/lib/modules/pos/credit_service.dart
new file mode 100644
index 0000000..cb96008
--- /dev/null
+++ b/lib/modules/pos/credit_service.dart
@@ -0,0 +1,346 @@
+import 'package:cloud_firestore/cloud_firestore.dart';
+
+/// Result of a credit mutation.
+class CreditOpResult {
+  final double previousBalance;
+  final double newBalance;
+  final double amountChanged; // positive for add, negative for repayment
+  final String type; // add_sale | repayment
+  final String? invoiceNumber;
+  final bool ledgerRecorded;
+  CreditOpResult({
+    required this.previousBalance,
+    required this.newBalance,
+    required this.amountChanged,
+    required this.type,
+    this.invoiceNumber,
+    this.ledgerRecorded = true,
+  });
+}
+
+class CustomerCreditService {
+  static final _fs = FirebaseFirestore.instance;
+
+  /// Adds a sale amount to customer credit (customer owes the business).
+  /// Creates a ledger entry at `customers/{id}/credit_ledger/{autoId}`.
+  static Future<CreditOpResult> addSaleOnCredit({
+    required String customerId,
+    required double amount,
+    required String invoiceNumber,
+  }) async {
+    if (amount <= 0) {
+      throw ArgumentError('Amount must be > 0');
+    }
+    final custRef = _fs.collection('customers').doc(customerId);
+    final ledgerRef = custRef.collection('credit_ledger').doc();
+    late CreditOpResult result;
+    await _fs.runTransaction((tx) async {
+      final snap = await tx.get(custRef);
+      if (!snap.exists) {
+        // Initialize minimal customer doc if somehow missing (prevent null crash)
+        tx.set(custRef, {'creditBalance': 0, 'createdAt': FieldValue.serverTimestamp()});
+      }
+      final data = snap.data() ?? <String, dynamic>{};
+      final prevRaw = data['creditBalance'] ?? data['khathaBalance'] ?? 0;
+      double prev = 0;
+      if (prevRaw is num) prev = prevRaw.toDouble();
+      else if (prevRaw is String) prev = double.tryParse(prevRaw) ?? 0;
+      final next = prev + amount;
+      tx.update(custRef, {
+        'creditBalance': next,
+        'creditUpdatedAt': FieldValue.serverTimestamp(),
+      });
+      tx.set(ledgerRef, {
+        'type': 'add_sale',
+        'amount': amount,
+        'balanceAfter': next,
+        'invoiceNumber': invoiceNumber,
+        'timestamp': FieldValue.serverTimestamp(),
+      });
+      result = CreditOpResult(
+        previousBalance: prev,
+        newBalance: next,
+        amountChanged: amount,
+        type: 'add_sale',
+        invoiceNumber: invoiceNumber,
+      );
+    });
+    return result;
+  }
+
+  /// Repays (reduces) customer credit. Amount is clamped to existing balance.
+  static Future<CreditOpResult> repayCredit({
+    required String customerId,
+    required double amount,
+  }) async {
+    if (amount <= 0) {
+      throw ArgumentError('Amount must be > 0');
+    }
+    final custRef = _fs.collection('customers').doc(customerId);
+    final ledgerRef = custRef.collection('credit_ledger').doc();
+    late CreditOpResult result;
+    try {
+      await _fs.runTransaction((tx) async {
+        final snap = await tx.get(custRef);
+        if (!snap.exists) {
+          throw StateError('Customer not found');
+        }
+        final data = snap.data() ?? <String, dynamic>{};
+        final prevRaw = data['creditBalance'] ?? data['khathaBalance'] ?? 0;
+        double prev = 0;
+        if (prevRaw is num) {
+          prev = prevRaw.toDouble();
+        } else if (prevRaw is String) {
+          prev = double.tryParse(prevRaw) ?? 0;
+        }
+        final repay = amount > prev ? prev : amount;
+        final next = prev - repay;
+        tx.update(custRef, {
+          'creditBalance': next,
+          'creditUpdatedAt': FieldValue.serverTimestamp(),
+        });
+        tx.set(ledgerRef, {
+          'type': 'repayment',
+          'amount': repay,
+          'balanceAfter': next,
+          'timestamp': FieldValue.serverTimestamp(),
+        });
+        result = CreditOpResult(
+          previousBalance: prev,
+          newBalance: next,
+          amountChanged: -repay,
+          type: 'repayment',
+          ledgerRecorded: true,
+        );
+      });
+      return result;
+    } on FirebaseException catch (e) {
+      // Permission denied fallback: try simple creditBalance decrement without ledger (if rules allow anonymous delta)
+      if (e.code == 'permission-denied') {
+        await _fs.runTransaction((tx) async {
+          final snap = await tx.get(custRef);
+          if (!snap.exists) {
+            throw StateError('Customer not found');
+          }
+          final data = snap.data() ?? <String, dynamic>{};
+          final prevRaw = data['creditBalance'] ?? data['khathaBalance'] ?? 0;
+          double prev = 0;
+          if (prevRaw is num) {
+            prev = prevRaw.toDouble();
+          } else if (prevRaw is String) {
+            prev = double.tryParse(prevRaw) ?? 0;
+          }
+          final repay = amount > prev ? prev : amount;
+          final next = prev - repay;
+          tx.update(custRef, {
+            'creditBalance': next,
+            'creditUpdatedAt': FieldValue.serverTimestamp(),
+          });
+          result = CreditOpResult(
+            previousBalance: prev,
+            newBalance: next,
+            amountChanged: -repay,
+            type: 'repayment',
+            ledgerRecorded: false,
+          );
+        });
+        return result;
+      }
+      rethrow;
+    }
+  }
+
+  /// Adjusts customer credit for a single checkout that might both:
+  ///  - add to credit (unpaid portion of this sale)
+  ///  - repay existing credit (excess cash paid relative to this sale)
+  /// Only one of [creditAdd] or [creditRepay] is typically > 0, but the
+  /// method safely handles both being > 0 by applying addition first then repayment.
+  /// Returns the net effect. Positive amountChanged means balance increased, negative means decreased.
+  static Future<CreditOpResult> adjustForCheckout({
+    required String customerId,
+    required double creditAdd,
+    required double creditRepay,
+    required String invoiceNumber,
+  }) async {
+    // Normalize inputs (no negatives)
+    final addPortion = creditAdd.isNaN ? 0.0 : creditAdd.clamp(0, double.infinity);
+    final repayPortion = creditRepay.isNaN ? 0.0 : creditRepay.clamp(0, double.infinity);
+    if (addPortion == 0 && repayPortion == 0) {
+      // Nothing to do: fetch current balance to return a result for consistency.
+      final snap = await _fs.collection('customers').doc(customerId).get();
+      final data = snap.data() ?? <String, dynamic>{};
+      final prevRaw = data['creditBalance'] ?? data['khathaBalance'] ?? 0;
+      double prev = 0;
+      if (prevRaw is num) prev = prevRaw.toDouble();
+      else if (prevRaw is String) prev = double.tryParse(prevRaw) ?? 0;
+      return CreditOpResult(
+        previousBalance: prev,
+        newBalance: prev,
+        amountChanged: 0,
+        type: 'noop',
+        invoiceNumber: invoiceNumber,
+        ledgerRecorded: false,
+      );
+    }
+
+    final custRef = _fs.collection('customers').doc(customerId);
+    // Pre-create ledger doc refs (up to two) for deterministic ordering inside transaction
+    final ledgerAddRef = addPortion > 0 ? custRef.collection('credit_ledger').doc() : null;
+    final ledgerRepayRef = repayPortion > 0 ? custRef.collection('credit_ledger').doc() : null;
+    late CreditOpResult result;
+
+  Future<CreditOpResult> txBody(Transaction tx) async {
+      final snap = await tx.get(custRef);
+      if (!snap.exists) {
+        // Initialize minimal customer doc to avoid nulls
+        tx.set(custRef, {'creditBalance': 0, 'createdAt': FieldValue.serverTimestamp()});
+      }
+      final data = snap.data() ?? <String, dynamic>{};
+      final prevRaw = data['creditBalance'] ?? data['khathaBalance'] ?? 0;
+      double prev = 0;
+      if (prevRaw is num) {
+        prev = prevRaw.toDouble();
+      } else if (prevRaw is String) {
+        prev = double.tryParse(prevRaw) ?? 0;
+      }
+
+      // Apply add then repayment ensuring we don't go negative.
+      double intermediate = prev + addPortion;
+  double repayClamp = repayPortion.clamp(0, intermediate).toDouble(); // cannot repay more than after addition
+      double next = intermediate - repayClamp;
+
+      tx.update(custRef, {
+        'creditBalance': next,
+        'creditUpdatedAt': FieldValue.serverTimestamp(),
+      });
+
+      if (ledgerAddRef != null && addPortion > 0) {
+        tx.set(ledgerAddRef, {
+          'type': 'add_sale',
+          'amount': addPortion,
+          'balanceAfter': intermediate, // balance after addition but before repayment
+          'invoiceNumber': invoiceNumber,
+          'timestamp': FieldValue.serverTimestamp(),
+        });
+      }
+      if (ledgerRepayRef != null && repayClamp > 0) {
+        tx.set(ledgerRepayRef, {
+          'type': 'repayment',
+          'amount': repayClamp,
+          'balanceAfter': next,
+          'invoiceNumber': invoiceNumber,
+          'timestamp': FieldValue.serverTimestamp(),
+        });
+      }
+
+      final net = (addPortion - repayClamp);
+      result = CreditOpResult(
+        previousBalance: prev,
+        newBalance: next,
+        amountChanged: net, // positive => added, negative => repaid
+        type: (addPortion > 0 && repayClamp > 0)
+            ? 'mixed'
+            : (addPortion > 0 ? 'add_sale' : 'repayment'),
+        invoiceNumber: invoiceNumber,
+        ledgerRecorded: true,
+      );
+      return result;
+    }
+
+    try {
+  await _fs.runTransaction(txBody);
+      return result;
+    } on FirebaseException catch (e) {
+      if (e.code == 'permission-denied') {
+        // Fallback without ledger entries.
+        await _fs.runTransaction((tx) async {
+          final snap = await tx.get(custRef);
+            if (!snap.exists) {
+              tx.set(custRef, {'creditBalance': 0, 'createdAt': FieldValue.serverTimestamp()});
+            }
+            final data = snap.data() ?? <String, dynamic>{};
+            final prevRaw = data['creditBalance'] ?? data['khathaBalance'] ?? 0;
+            double prev = 0;
+            if (prevRaw is num) {
+              prev = prevRaw.toDouble();
+            } else if (prevRaw is String) {
+              prev = double.tryParse(prevRaw) ?? 0;
+            }
+            double intermediate = prev + addPortion;
+            double repayClamp = repayPortion.clamp(0, intermediate).toDouble();
+            double next = intermediate - repayClamp;
+            tx.update(custRef, {
+              'creditBalance': next,
+              'creditUpdatedAt': FieldValue.serverTimestamp(),
+            });
+            final net = addPortion - repayClamp;
+            result = CreditOpResult(
+              previousBalance: prev,
+              newBalance: next,
+              amountChanged: net,
+              type: (addPortion > 0 && repayClamp > 0)
+                  ? 'mixed'
+                  : (addPortion > 0 ? 'add_sale' : 'repayment'),
+              invoiceNumber: invoiceNumber,
+              ledgerRecorded: false,
+            );
+        });
+        return result;
+      }
+      rethrow;
+    }
+  }
+
+  /// Ensures the customer document has a numeric `creditBalance` field.
+  /// If the doc exists and lacks both `creditBalance` and legacy `khathaBalance`,
+  /// this will set `creditBalance` to 0 (idempotent safe initialization).
+  static Future<void> ensureCreditField(String customerId) async {
+    final ref = _fs.collection('customers').doc(customerId);
+    try {
+      await _fs.runTransaction((tx) async {
+        final snap = await tx.get(ref);
+        if (!snap.exists) return; // don't create customer implicitly
+        final data = snap.data() ?? <String, dynamic>{};
+        if (!data.containsKey('creditBalance') && !data.containsKey('khathaBalance')) {
+          tx.update(ref, {
+            'creditBalance': 0.0,
+            'creditUpdatedAt': FieldValue.serverTimestamp(),
+          });
+        }
+      });
+    } catch (e) {
+      // Swallow silently; absence just means we couldn't initialize.
+    }
+  }
+
+  /// Pure helper to compute credit mixing outcomes without side effects.
+  /// [saleDue] - amount due for current cart after discounts/redemptions.
+  /// [existingCredit] - current outstanding credit before this sale.
+  /// [paidNow] - amount customer pays now.
+  /// Returns a map: {add: double, repay: double, net: double, newCredit: double}
+  static Map<String, double> computeCreditMix({
+    required double saleDue,
+    required double existingCredit,
+    required double paidNow,
+  }) {
+    final safeSale = saleDue.isNaN ? 0.0 : saleDue.clamp(0, double.infinity);
+    final safeExisting = existingCredit.isNaN ? 0.0 : existingCredit.clamp(0, double.infinity);
+    final safePaid = paidNow.isNaN ? 0.0 : paidNow.clamp(0, double.infinity);
+    double addPortion = 0;
+    double repayPortion = 0;
+    if (safePaid >= safeSale) {
+      final excess = safePaid - safeSale;
+      repayPortion = excess.clamp(0, safeExisting).toDouble();
+    } else {
+      addPortion = (safeSale - safePaid).toDouble();
+    }
+    final newCredit = safeExisting + addPortion - repayPortion;
+    final net = addPortion - repayPortion; // positive => increase, negative => decrease
+    return {
+      'add': addPortion,
+      'repay': repayPortion,
+      'net': net,
+      'newCredit': newCredit,
+    };
+  }
+}
diff --git a/lib/modules/pos/pos.dart b/lib/modules/pos/pos.dart
index 8da7640..0f97479 100644
--- a/lib/modules/pos/pos.dart
+++ b/lib/modules/pos/pos.dart
@@ -163,6 +163,11 @@ class _PosPageState extends State<PosPage> {
   void completeSale() {
     if (cart.isEmpty) return _snack('Cart is empty');
 
+    // If credit payment selected, record credit before clearing cart
+    if (selectedPaymentMode == PaymentMode.credit) {
+      _applyCreditLedger();
+    }
+
     // Update stock
     for (final item in cart.values) {
       item.product.stock -= item.qty;
@@ -507,6 +512,20 @@ class _PosPageState extends State<PosPage> {
           ...taxesByRate.entries.map((e) => _kv('GST ${e.key}%', e.value)),
           const Divider(),
           _kv('Grand Total', grandTotal, bold: true),
+          if (selectedCustomer != null && selectedCustomer!.id != 'walkin')
+            Padding(
+              padding: const EdgeInsets.only(top:4.0,bottom: 4.0),
+              child: Row(
+                mainAxisAlignment: MainAxisAlignment.spaceBetween,
+                children:[
+                  const Text('Credit Balance', style: TextStyle(fontSize:12,fontWeight: FontWeight.w500)),
+                  Text(
+                    '₹${(selectedCustomer!.creditBalance).toStringAsFixed(2)}',
+                    style: const TextStyle(fontSize:12,fontWeight: FontWeight.w600),
+                  )
+                ],
+              ),
+            ),
           const SizedBox(height: 10),
           // Payment mode quick buttons
           Row(children: [
@@ -514,7 +533,7 @@ class _PosPageState extends State<PosPage> {
             const SizedBox(width: 8),
             Expanded(child: _payModeButton(PaymentMode.upi, 'UPI', Icons.qr_code)),
             const SizedBox(width: 8),
-            Expanded(child: _payModeButton(PaymentMode.card, 'Card', Icons.credit_card)),
+            Expanded(child: _payModeButton(PaymentMode.credit, 'Credit', Icons.receipt_long)),
           ]),
           const SizedBox(height: 10),
           Row(children: [
@@ -540,7 +559,17 @@ class _PosPageState extends State<PosPage> {
   Widget _payModeButton(PaymentMode mode, String label, IconData icon) {
     final selected = selectedPaymentMode == mode;
     return OutlinedButton.icon(
-      onPressed: () => setState(() => selectedPaymentMode = mode),
+      onPressed: () async {
+        if (mode == PaymentMode.credit) {
+          if (selectedCustomer == null || selectedCustomer!.id == 'walkin') {
+            _snack('Select a saved customer to use Credit');
+            return;
+          }
+          final ok = await _promptCreditAmount();
+          if (!ok) return; // user cancelled
+        }
+        setState(() => selectedPaymentMode = mode);
+      },
       icon: Icon(icon, color: selected ? Theme.of(context).colorScheme.primary : null),
       label: Text(label),
       style: OutlinedButton.styleFrom(
@@ -556,6 +585,85 @@ class _PosPageState extends State<PosPage> {
     );
   }
 
+  Future<bool> _promptCreditAmount() async {
+    final controller = TextEditingController(text: grandTotal.toStringAsFixed(2));
+    final result = await showDialog<double>(
+      context: context,
+      builder: (ctx) {
+        return AlertDialog(
+          title: const Text('Credit Amount'),
+            content: Column(
+              mainAxisSize: MainAxisSize.min,
+              children: [
+                Text('Grand Total: ₹${grandTotal.toStringAsFixed(2)}', style: const TextStyle(fontSize: 13)),
+                const SizedBox(height: 8),
+                TextField(
+                  controller: controller,
+                  keyboardType: const TextInputType.numberWithOptions(decimal: true),
+                  decoration: const InputDecoration(labelText: 'Credit Amount (₹)', border: OutlineInputBorder()),
+                ),
+              ],
+            ),
+          actions: [
+            TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
+            ElevatedButton(
+              onPressed: () {
+                final v = double.tryParse(controller.text.trim());
+                if (v == null || v <= 0) {
+                  _snack('Enter valid amount');
+                  return;
+                }
+                Navigator.pop(ctx, v);
+              },
+              child: const Text('Apply'),
+            ),
+          ],
+        );
+      },
+    );
+    if (result == null) return false;
+    _pendingCreditAmount = result;
+    return true;
+  }
+
+  double? _pendingCreditAmount;
+
+  Future<void> _applyCreditLedger() async {
+    if (_pendingCreditAmount == null) {
+      // fallback: use grandTotal
+      _pendingCreditAmount = grandTotal;
+    }
+    final amt = _pendingCreditAmount!;
+    if (selectedCustomer == null || selectedCustomer!.id == 'walkin') return;
+    final old = selectedCustomer!.creditBalance;
+    final updated = old + amt;
+    final cust = selectedCustomer!;
+    // Update local model (since demo list) – replace in customers list
+    final idx = customers.indexWhere((c) => c.id == cust.id);
+    if (idx != -1) {
+      customers[idx] = Customer(
+        id: cust.id,
+        name: cust.name,
+        email: cust.email,
+        phone: cust.phone,
+        status: cust.status,
+        totalSpend: cust.totalSpend + grandTotal, // optionally add to spend
+        rewardsPoints: cust.rewardsPoints,
+        discountPercent: cust.discountPercent,
+        creditBalance: updated,
+      );
+      setState(() => selectedCustomer = customers[idx]);
+    }
+    // Firestore persistence if we have a reference path pattern: customers collection assumed
+    try {
+      await FirebaseFirestore.instance.collection('customers').doc(cust.id).update({'creditBalance': updated});
+    } catch (e) {
+      // Non-fatal, show snackbar
+      _snack('Credit save pending (offline?)');
+    }
+    _pendingCreditAmount = null;
+  }
+
   // Payment split row removed
 
   Widget _kv(String label, double value, {bool bold = false}) {
@@ -633,6 +741,7 @@ class Customer {
   final double totalSpend;
   final double rewardsPoints; // allow fractional points
   final double discountPercent; // derived suggested discount
+  final double creditBalance; // running outstanding credit (customer owes)
 
   Customer({
     required this.id,
@@ -643,6 +752,7 @@ class Customer {
     this.totalSpend = 0.0,
   this.rewardsPoints = 0.0,
     this.discountPercent = 0.0,
+  this.creditBalance = 0.0,
   });
 
   factory Customer.fromDoc(DocumentSnapshot<Map<String, dynamic>> doc) {
@@ -669,16 +779,20 @@ class Customer {
       discount = loyaltyDisc.toDouble();
     } else {
       switch (tier) {
-        case 'gold':
-          discount = 10; break;
-        case 'silver':
-          discount = 5; break;
-        case 'bronze':
-          discount = 2; break;
+        case 'gold': {
+          discount = 10; break; }
+        case 'silver': {
+          discount = 5; break; }
+        case 'bronze': {
+          discount = 2; break; }
         default:
           discount = 0;
       }
     }
+  final creditRaw = data['creditBalance'] ?? data['khathaBalance']; // migrate old field
+  double credit = 0;
+  if (creditRaw is num) credit = creditRaw.toDouble();
+  else if (creditRaw is String) credit = double.tryParse(creditRaw) ?? 0;
   return Customer(
       id: doc.id,
       name: name,
@@ -688,6 +802,7 @@ class Customer {
       totalSpend: spend,
       rewardsPoints: rewards,
       discountPercent: discount,
+      creditBalance: credit,
     );
   }
 }
@@ -709,10 +824,15 @@ class HeldOrder {
   HeldOrder({required this.id, required this.timestamp, required this.items, required this.discountType, required this.discountValueText});
 }
 
-enum PaymentMode { cash, upi, card, wallet }
+enum PaymentMode { cash, upi, credit, wallet }
 
 extension PaymentModeX on PaymentMode {
-  String get label => switch (this) { PaymentMode.cash => 'Cash', PaymentMode.upi => 'UPI', PaymentMode.card => 'Card', PaymentMode.wallet => 'Wallet' };
+  String get label => switch (this) {
+    PaymentMode.cash => 'Cash',
+    PaymentMode.upi => 'UPI',
+  PaymentMode.credit => 'Credit',
+    PaymentMode.wallet => 'Wallet'
+  };
 }
 
 // Payment split model removed
diff --git a/lib/modules/pos/pos_cashier.dart b/lib/modules/pos/pos_cashier.dart
new file mode 100644
index 0000000..e67f4da
--- /dev/null
+++ b/lib/modules/pos/pos_cashier.dart
@@ -0,0 +1,487 @@
+import 'dart:async';
+import 'package:flutter/material.dart';
+import 'package:cloud_firestore/cloud_firestore.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
+import '../../core/auth/auth.dart';
+
+/// Cashier screen with a primary card panel for shift summary and cash drawer actions.
+class PosCashierScreen extends ConsumerStatefulWidget {
+  const PosCashierScreen({super.key});
+
+  @override
+  ConsumerState<PosCashierScreen> createState() => _PosCashierScreenState();
+}
+
+class _PosCashierScreenState extends ConsumerState<PosCashierScreen> {
+  bool _shiftOpen = false;
+  double _openingFloat = 0;
+  double _cashSales = 0; // Sum of today's invoices paid in cash (live)
+  // Cash In removed from summary
+  double _recentInvoicesTotal = 0; // Sum of totals from recent invoices (last 10)
+  double _recentInvoicesCashTotal = 0; // Sum of cash-only totals from recent invoices
+  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _todayCashSub;
+ 
+  Future<void> _promptAmount({required String title, required void Function(double) onSubmit}) async {
+    final ctrl = TextEditingController();
+    final formKey = GlobalKey<FormState>();
+    final val = await showDialog<double>(
+      context: context,
+      builder: (ctx) => AlertDialog(
+        title: Text(title),
+        content: Form(
+          key: formKey,
+          child: TextFormField(
+            controller: ctrl,
+            autofocus: true,
+            decoration: const InputDecoration(labelText: 'Amount', prefixText: '₹'),
+            keyboardType: const TextInputType.numberWithOptions(decimal: true),
+            validator: (v) {
+              if (v == null || v.trim().isEmpty) return 'Required';
+              final d = double.tryParse(v.trim());
+              if (d == null || d < 0) return 'Invalid';
+              return null;
+            },
+          ),
+        ),
+        actions: [
+          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
+          FilledButton(
+            onPressed: () {
+              if (!formKey.currentState!.validate()) return;
+              final d = double.parse(ctrl.text.trim());
+              Navigator.pop(ctx, d);
+            },
+            child: const Text('Save'),
+          ),
+        ],
+      ),
+    );
+    if (val != null) {
+      onSubmit(val);
+    }
+  }
+
+  void _openShift() async {
+    if (_shiftOpen) return;
+    await _promptAmount(title: 'Opening balance', onSubmit: (amt) {
+      setState(() {
+  _openingFloat = amt;
+        _cashSales = 0; // will refresh from listener shortly
+  // opened/closed timestamps removed from simplified summary
+        _shiftOpen = true;
+      });
+    });
+  }
+
+  void _closeShift() {
+    if (!_shiftOpen) return;
+    setState(() {
+  // closed timestamp removed
+      _shiftOpen = false;
+    });
+    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Shift closed')));
+  }
+
+  @override
+  Widget build(BuildContext context) {
+  // (surfaceColor no longer needed after removing enhancements panel)
+    final user = ref.watch(authStateProvider);
+    final isWide = MediaQuery.of(context).size.width >= 1100;
+    final summaryCard = _buildShiftSummaryCard(userEmail: user?.email);
+    final invoicesCard = _buildRecentInvoicesCard(userEmail: user?.email);
+
+    return Scaffold(
+      appBar: AppBar(title: const Text('Cashier')),
+      body: Scrollbar(
+        thumbVisibility: true,
+        child: SingleChildScrollView(
+          padding: const EdgeInsets.all(16),
+          child: isWide
+              ? Row(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    // Decreased width of shift summary by reducing flex
+                    Expanded(flex: 4, child: summaryCard),
+                    const SizedBox(width: 16),
+                    Expanded(flex: 7, child: invoicesCard),
+                  ],
+                )
+              : Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    summaryCard,
+                    const SizedBox(height: 16),
+                    invoicesCard,
+                  ],
+                ),
+        ),
+      ),
+    );
+  }
+
+  @override
+  void initState() {
+    super.initState();
+    _subscribeTodayCashSales();
+  }
+
+  void _subscribeTodayCashSales() {
+    final now = DateTime.now();
+    final start = DateTime(now.year, now.month, now.day);
+    final end = start.add(const Duration(days: 1));
+    final query = FirebaseFirestore.instance
+        .collection('invoices')
+        .where('timestampMs', isGreaterThanOrEqualTo: start.millisecondsSinceEpoch)
+        .where('timestampMs', isLessThan: end.millisecondsSinceEpoch);
+    _todayCashSub?.cancel();
+    _todayCashSub = query.snapshots().listen((snap) {
+      double total = 0;
+      for (final d in snap.docs) {
+        final data = d.data();
+        final mode = (data['paymentMode'] ?? '').toString().toLowerCase();
+        if (mode.contains('cash')) {
+          final val = (data['grandTotal'] is num) ? (data['grandTotal'] as num).toDouble() : 0.0;
+          total += val;
+        }
+      }
+      if (mounted) {
+        setState(() => _cashSales = total);
+      }
+    });
+  }
+
+  @override
+  void dispose() {
+    _todayCashSub?.cancel();
+    super.dispose();
+  }
+
+  Widget _buildShiftSummaryCard({required String? userEmail}) {
+    return Card(
+      elevation: 1,
+      clipBehavior: Clip.antiAlias,
+      child: Padding(
+        padding: const EdgeInsets.all(16),
+        child: Column(
+          crossAxisAlignment: CrossAxisAlignment.start,
+          children: [
+            Text('Shift Summary', style: Theme.of(context).textTheme.titleLarge),
+            const SizedBox(height: 12),
+            Wrap(
+              spacing: 24,
+              runSpacing: 12,
+              children: [
+                _openingBalanceCluster(),
+                _cashSalesCluster(),
+                _closingBalanceCluster(),
+              ],
+            ),
+            const SizedBox(height: 20),
+            Row(
+              children: [
+                if (!_shiftOpen)
+                  FilledButton.icon(
+                    icon: const Icon(Icons.play_arrow),
+                    onPressed: _openShift,
+                    label: const Text('Open Shift'),
+                  )
+                else OutlinedButton.icon(
+                  icon: const Icon(Icons.stop_circle_outlined),
+                  onPressed: _closeShift,
+                  label: const Text('Close Shift'),
+                ),
+              ],
+            ),
+            const SizedBox(height: 12),
+            Text(
+              'Note: Sales figures are placeholders; integrate with invoices collection to compute real-time cash sales.',
+              style: Theme.of(context).textTheme.bodySmall,
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+
+  Widget _buildRecentInvoicesCard({required String? userEmail}) {
+    return Card(
+      elevation: 1,
+      clipBehavior: Clip.antiAlias,
+      child: Padding(
+        padding: const EdgeInsets.all(16),
+        child: Column(
+          crossAxisAlignment: CrossAxisAlignment.start,
+          children: [
+            Text('Recent Invoices', style: Theme.of(context).textTheme.titleLarge),
+            const SizedBox(height: 12),
+            // Constrain height and allow vertical scrolling to avoid overflow.
+            ConstrainedBox(
+              constraints: const BoxConstraints(maxHeight: 520),
+              child: Scrollbar(
+                thumbVisibility: true,
+                child: SingleChildScrollView(
+                  scrollDirection: Axis.vertical,
+                  child: SizedBox(
+                    width: double.infinity,
+                    child: _RecentInvoicesTable(
+                      currentUserEmail: userEmail,
+                      onOverallTotal: (v) {
+                        if (mounted && _recentInvoicesTotal != v) {
+                          setState(() => _recentInvoicesTotal = v);
+                        }
+                      },
+                      onTotals: (cash, overall) {
+                        if (!mounted) return;
+                        bool changed = false;
+                        if (_recentInvoicesCashTotal != cash) { _recentInvoicesCashTotal = cash; changed = true; }
+                        if (_recentInvoicesTotal != overall) { _recentInvoicesTotal = overall; changed = true; }
+                        if (changed) setState(() {});
+                      },
+                    ),
+                  ),
+                ),
+              ),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+
+  // _metric helper removed after consolidating into cluster widgets.
+
+  Widget _openingBalanceCluster() {
+    final theme = Theme.of(context);
+    TextStyle? labelStyle = theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant);
+    TextStyle? valueStyle = theme.textTheme.bodyMedium;
+    TextStyle? valueBold = valueStyle?.copyWith(fontWeight: FontWeight.bold);
+    return SizedBox(
+      width: 220,
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Text('Opening balance', style: labelStyle?.copyWith(fontSize: 16, fontWeight: FontWeight.w600)),
+          const SizedBox(height: 6),
+          Row(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Text('Cash', style: labelStyle?.copyWith(fontSize: 12, fontWeight: FontWeight.w600)),
+                    const SizedBox(height: 2),
+                    Text(_currency(_recentInvoicesCashTotal), style: valueStyle),
+                  ],
+                ),
+              ),
+              const SizedBox(width: 24),
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Text('Total', style: labelStyle?.copyWith(fontSize: 12, fontWeight: FontWeight.w600)),
+                    const SizedBox(height: 2),
+                    Text(_currency(_recentInvoicesTotal), style: valueBold),
+                  ],
+                ),
+              ),
+            ],
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _cashSalesCluster() {
+    final theme = Theme.of(context);
+    TextStyle? labelStyle = theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant);
+    TextStyle? valueStyle = theme.textTheme.bodyMedium;
+    TextStyle? valueBold = valueStyle?.copyWith(fontWeight: FontWeight.bold);
+    return SizedBox(
+      width: 220,
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Text('Cash Sales', style: labelStyle?.copyWith(fontSize: 16, fontWeight: FontWeight.w600)),
+          const SizedBox(height: 6),
+          Row(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Text('Cash', style: labelStyle?.copyWith(fontSize: 12, fontWeight: FontWeight.w600)),
+                    const SizedBox(height: 2),
+                    Text(_currency(_cashSales), style: valueStyle),
+                  ],
+                ),
+              ),
+              const SizedBox(width: 24),
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Text('Total', style: labelStyle?.copyWith(fontSize: 12, fontWeight: FontWeight.w600)),
+                    const SizedBox(height: 2),
+                    Text(_currency(_openingFloat + _cashSales), style: valueBold),
+                  ],
+                ),
+              ),
+            ],
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _closingBalanceCluster() {
+    final theme = Theme.of(context);
+    final labelStyle = theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant);
+    final valueStyle = theme.textTheme.bodyMedium;
+    final valueBold = valueStyle?.copyWith(fontWeight: FontWeight.bold);
+    return SizedBox(
+      width: 220,
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Text('Closing Balance', style: labelStyle?.copyWith(fontSize: 16, fontWeight: FontWeight.w600)),
+          const SizedBox(height: 6),
+          Row(
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Text('Cash', style: labelStyle?.copyWith(fontSize: 12, fontWeight: FontWeight.w600)),
+                    const SizedBox(height: 2),
+                    Text(_currency(_recentInvoicesCashTotal), style: valueStyle),
+                  ],
+                ),
+              ),
+              const SizedBox(width: 24),
+              Expanded(
+                child: Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    Text('Total', style: labelStyle?.copyWith(fontSize: 12, fontWeight: FontWeight.w600)),
+                    const SizedBox(height: 2),
+                    Text(_currency(_recentInvoicesTotal), style: valueBold),
+                  ],
+                ),
+              ),
+            ],
+          ),
+        ],
+      ),
+    );
+  }
+
+  // _timeFmt removed (no longer showing opened/closed times)
+  String _currency(double v) => '₹${v.toStringAsFixed(2)}';
+}
+
+class _RecentInvoicesTable extends StatelessWidget {
+  final String? currentUserEmail;
+  final ValueChanged<double>? onOverallTotal; // legacy single total callback
+  final void Function(double cashTotal, double overallTotal)? onTotals; // new combined callback
+  const _RecentInvoicesTable({required this.currentUserEmail, this.onOverallTotal, this.onTotals});
+
+  @override
+  Widget build(BuildContext context) {
+    final query = FirebaseFirestore.instance
+        .collection('invoices')
+        .orderBy('timestampMs', descending: true)
+        .limit(10);
+    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
+      stream: query.snapshots(),
+      builder: (context, snap) {
+        if (snap.hasError) {
+          return Text('Error: ${snap.error}', style: TextStyle(color: Theme.of(context).colorScheme.error));
+        }
+        if (!snap.hasData) {
+          return const SizedBox(height: 120, child: Center(child: CircularProgressIndicator()));
+        }
+        final docs = snap.data!.docs;
+        if (docs.isEmpty) {
+          return const Padding(
+            padding: EdgeInsets.symmetric(vertical: 24.0),
+            child: Center(child: Text('No invoices yet')),
+          );
+        }
+        // Aggregate totals per mode
+        double totalCash = 0, totalUpiCard = 0, overallTotal = 0;
+        final rows = <DataRow>[];
+        for (final d in docs) {
+          final data = d.data();
+          final number = data['invoiceNumber'] ?? d.id;
+          final tsMs = (data['timestampMs'] is int) ? data['timestampMs'] as int : null;
+            DateTime? dt; if (tsMs != null) { dt = DateTime.fromMillisecondsSinceEpoch(tsMs); }
+          final mode = (data['paymentMode'] ?? '').toString().toLowerCase();
+          final total = (data['grandTotal'] is num) ? (data['grandTotal'] as num).toDouble() : 0.0;
+          overallTotal += total;
+          double cash = 0, upiCard = 0;
+          if (mode.contains('cash')) { cash = total; totalCash += total; }
+          else if (mode.contains('upi') || mode.contains('card') || mode.contains('credit')) { upiCard = total; totalUpiCard += total; }
+          rows.add(DataRow(cells: [
+            DataCell(Text('$number')),
+            DataCell(Text(dt == null ? '-' : _fmt(dt))),
+            DataCell(Text(currentUserEmail ?? '-')), // placeholder; invoice doesn't store cashier yet
+            DataCell(Text(cash == 0 ? '' : _amt(cash))),
+            DataCell(Text(upiCard == 0 ? '' : _amt(upiCard))),
+            DataCell(Text(_amt(total))),
+          ]));
+        }
+        // Totals row
+        rows.add(DataRow(cells: [
+          const DataCell(Text('TOTAL', style: TextStyle(fontWeight: FontWeight.bold))),
+          const DataCell(Text('')),
+          const DataCell(Text('')),
+          DataCell(Text(_amt(totalCash), style: const TextStyle(fontWeight: FontWeight.bold))),
+          DataCell(Text(_amt(totalUpiCard), style: const TextStyle(fontWeight: FontWeight.bold))),
+          DataCell(Text(_amt(overallTotal), style: const TextStyle(fontWeight: FontWeight.bold))),
+        ]));
+
+        // Notify parent of overall total (sum of last 10 invoices) for closing balance display.
+        if (onOverallTotal != null || onTotals != null) {
+          WidgetsBinding.instance.addPostFrameCallback((_) {
+            if (onOverallTotal != null) onOverallTotal!(overallTotal);
+            if (onTotals != null) onTotals!(totalCash, overallTotal);
+          });
+        }
+
+        final headerStyle = Theme.of(context).textTheme.bodySmall?.copyWith(
+              fontSize: 14,
+              fontWeight: FontWeight.w600,
+              letterSpacing: .2,
+            );
+        return SingleChildScrollView(
+          scrollDirection: Axis.horizontal,
+          child: DataTable(
+            columnSpacing: 35,
+            headingRowHeight: 40,
+            columns: [
+              DataColumn(label: Text('Invoice #', style: headerStyle)),
+              DataColumn(label: Text('Date & Time', style: headerStyle)),
+              DataColumn(label: Text('Cashier', style: headerStyle)),
+              DataColumn(label: Text('Cash', style: headerStyle)),
+              DataColumn(label: Text('UPI/Card', style: headerStyle)),
+              DataColumn(label: Text('Total', style: headerStyle)),
+            ],
+            rows: rows,
+          ),
+        );
+      },
+    );
+  }
+
+  static String _fmt(DateTime dt) {
+    final d = dt;
+    return '${d.day.toString().padLeft(2, '0')}/${d.month.toString().padLeft(2, '0')} ${d.hour.toString().padLeft(2, '0')}:${d.minute.toString().padLeft(2, '0')}';
+  }
+  static String _amt(double v) => '₹${v.toStringAsFixed(2)}';
+}
+
+
diff --git a/lib/modules/pos/pos_checkout.dart b/lib/modules/pos/pos_checkout.dart
index 3ecc33c..f505909 100644
--- a/lib/modules/pos/pos_checkout.dart
+++ b/lib/modules/pos/pos_checkout.dart
@@ -1,10 +1,11 @@
 import 'dart:async';
 import 'package:flutter/material.dart';
+import 'package:flutter/foundation.dart';
+import 'package:cloud_firestore/cloud_firestore.dart';
 import 'pos.dart';
-// Removed printer setup button from this panel; printer setup now appears in checkout popup dialog.
+import 'print_settings.dart';
 
-// Clean rebuilt checkout panel with inline printer configuration button.
-class CheckoutPanel extends StatelessWidget {
+class CheckoutPanel extends StatefulWidget {
   final Stream<List<Customer>> customersStream;
   final List<Customer> initialCustomers;
   final Customer? selectedCustomer;
@@ -23,10 +24,12 @@ class CheckoutPanel extends StatelessWidget {
   final Map<String, CartItem> cart;
   final Map<String, double> lineTaxes;
   final VoidCallback onCheckout;
-  final VoidCallback? onQuickPrint; // direct print
+  // For mixed credit checkout (cart present + credit payment entered)
+  final void Function(double amount)? onCheckoutCreditMix;
+  final VoidCallback? onQuickPrint;
   final PaymentMode selectedPaymentMode;
   final ValueChanged<PaymentMode> onPaymentModeChanged;
-
+  final Future<void> Function(double amount)? onPayCredit; // repay credit without creating a new sale
   const CheckoutPanel({
     super.key,
     required this.customersStream,
@@ -47,94 +50,168 @@ class CheckoutPanel extends StatelessWidget {
     required this.cart,
     required this.lineTaxes,
   required this.onCheckout,
-  this.onQuickPrint,
+  this.onCheckoutCreditMix,
+    this.onQuickPrint,
     required this.selectedPaymentMode,
     required this.onPaymentModeChanged,
+    this.onPayCredit,
   });
+  @override
+  State<CheckoutPanel> createState() => _CheckoutPanelState();
+}
 
+class _CheckoutPanelState extends State<CheckoutPanel> {
+  late final ScrollController _scrollCtrl;
+  final TextEditingController _creditAmountCtrl = TextEditingController();
+  @override
+  void initState() {
+    super.initState();
+    _scrollCtrl = ScrollController();
+    _creditAmountCtrl.addListener(() => setState(() {}));
+  }
+  @override
+  void dispose() {
+    _scrollCtrl.dispose();
+    _creditAmountCtrl.dispose();
+    super.dispose();
+  }
   @override
   Widget build(BuildContext context) {
+    final selectedCustomer = widget.selectedCustomer;
     final taxesByRate = <int, double>{};
-    for (final it in cart.values) {
-      final tax = lineTaxes[it.product.sku] ?? 0.0;
+    for (final it in widget.cart.values) {
+      final tax = widget.lineTaxes[it.product.sku] ?? 0.0;
       taxesByRate.update(it.product.taxPercent, (v) => v + tax, ifAbsent: () => tax);
     }
+    final content = SingleChildScrollView(
+      controller: _scrollCtrl,
+      primary: false,
+      padding: const EdgeInsets.all(10),
+      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
+        _CustomerDropdown(
+          customersStream: widget.customersStream,
+          initialCustomers: widget.initialCustomers,
+          selected: selectedCustomer,
+          onSelected: widget.onCustomerSelected,
+          walkIn: widget.walkIn,
+        ),
+        const SizedBox(height: 6),
+        _CustomerInfo(
+          selected: selectedCustomer,
+          creditActive: widget.selectedPaymentMode == PaymentMode.credit,
+        ),
+        const SizedBox(height: 8),
+        _kv('Subtotal', widget.subtotal),
+        _kv('Discount', -widget.discountValue),
+        if (widget.redeemValue > 0) _kv('Redeemed (Pts)', -widget.redeemValue),
+        const SizedBox(height: 6),
+        const Text('GST Breakdown'),
+        ...taxesByRate.entries.map((e) => _kv('GST ${e.key}%', e.value)),
+        const Divider(),
+        _kv('Grand Total', widget.grandTotal),
+        if (widget.redeemValue > 0) _kv('Redeem Applied', -widget.redeemValue),
+        _kv('Payable', widget.payableTotal, bold: true),
+        const SizedBox(height: 10),
+        _RedeemSection(
+          controller: widget.redeemPointsController,
+          availablePoints: widget.getAvailablePoints(),
+          redeemValue: widget.redeemValue,
+          onChange: widget.onRedeemChanged,
+          onMax: widget.onRedeemMax,
+          redeemedPoints: widget.getRedeemedPoints(),
+        ),
+        const SizedBox(height: 10),
+        Row(children: [
+          Expanded(child: _payModeButton(context, PaymentMode.cash, 'Cash', Icons.payments)),
+          const SizedBox(width: 8),
+            Expanded(child: _payModeButton(context, PaymentMode.upi, 'UPI', Icons.qr_code)),
+            const SizedBox(width: 8),
+            Expanded(child: _payModeButton(context, PaymentMode.credit, 'Credit', Icons.receipt_long)),
+          ]),
+        if (widget.selectedPaymentMode == PaymentMode.credit) ...[
+          const SizedBox(height: 8),
+          TextField(
+            controller: _creditAmountCtrl,
+            keyboardType: const TextInputType.numberWithOptions(decimal: true),
+            decoration: const InputDecoration(
+              labelText: 'Amount Paid Now (₹)',
+              prefixIcon: Icon(Icons.receipt_long),
+              border: OutlineInputBorder(),
+              helperText: 'Leave blank = 0. Less than payable → rest becomes new credit. More than payable → extra repays old credit.',
+            ),
+          ),
+          const SizedBox(height: 4),
+          _CreditPreview(
+            entered: double.tryParse(_creditAmountCtrl.text.trim()) ?? 0,
+            payable: widget.payableTotal,
+            existingCredit: widget.selectedCustomer?.creditBalance ?? 0,
+          ),
+        ],
+        const SizedBox(height: 12),
+        Row(children: [
+          ElevatedButton.icon(
+            onPressed: () { final qp = widget.onQuickPrint; if (qp != null) qp(); },
+            icon: const Icon(Icons.print),
+            label: const Text('Print'),
+          ),
+          const SizedBox(width: 8),
+          IconButton(
+            tooltip: 'Print Settings',
+            onPressed: () => _openPrintSettings(context),
+            icon: const Icon(Icons.settings),
+          ),
+          const SizedBox(width: 8),
+          Expanded(
+            child: ElevatedButton.icon(
+              onPressed: () {
+                if (widget.selectedPaymentMode == PaymentMode.credit) {
+                  final amt = double.tryParse(_creditAmountCtrl.text.trim()) ?? 0;
+                  // If there is a cart (mixed sale) use mixed callback, else repayment-only callback
+                  if (kDebugMode) {
+                    debugPrint('[CheckoutPanel] Credit button pressed cartItems=${widget.cart.length} amt=$amt mixCb=${widget.onCheckoutCreditMix!=null} repayCb=${widget.onPayCredit!=null}');
+                  }
+                  if (widget.cart.isNotEmpty) {
+                    if (widget.onCheckoutCreditMix != null) {
+                      widget.onCheckoutCreditMix!(amt);
+                    } else if (kDebugMode) {
+                      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Missing credit mix callback')));
+                    }
+                  } else {
+                    if (widget.onPayCredit != null) {
+                      widget.onPayCredit!(amt);
+                    } else if (kDebugMode) {
+                      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Missing credit repay callback')));
+                    }
+                  }
+                } else {
+                  widget.onCheckout();
+                }
+              },
+              icon: const Icon(Icons.check_circle),
+              label: Text(widget.selectedPaymentMode == PaymentMode.credit ? 'Checkout (Credit Mix)' : 'Checkout'),
+            ),
+          ),
+        ]),
+      ]),
+    );
     return Card(
       child: Scrollbar(
+        controller: _scrollCtrl,
         thumbVisibility: true,
-        child: SingleChildScrollView(
-          padding: const EdgeInsets.all(10.0),
-          child: Column(
-            crossAxisAlignment: CrossAxisAlignment.start,
-            children: [
-              _CustomerDropdown(
-                customersStream: customersStream,
-                initialCustomers: initialCustomers,
-                selected: selectedCustomer,
-                onSelected: onCustomerSelected,
-                walkIn: walkIn,
-              ),
-              const SizedBox(height: 6),
-              _CustomerInfo(selected: selectedCustomer),
-              const SizedBox(height: 8),
-              _kv('Subtotal', subtotal),
-              _kv('Discount', -discountValue),
-              if (redeemValue > 0) _kv('Redeemed (Pts)', -redeemValue),
-              const SizedBox(height: 6),
-              const Text('GST Breakdown'),
-              ...taxesByRate.entries.map((e) => _kv('GST ${e.key}%', e.value)),
-              const Divider(),
-              _kv('Grand Total', grandTotal),
-              if (redeemValue > 0) _kv('Redeem Applied', -redeemValue),
-              _kv('Payable', payableTotal, bold: true),
-              const SizedBox(height: 10),
-              _RedeemSection(
-                controller: redeemPointsController,
-                availablePoints: getAvailablePoints(),
-                redeemValue: redeemValue,
-                onChange: onRedeemChanged,
-                onMax: onRedeemMax,
-                redeemedPoints: getRedeemedPoints(),
-              ),
-              Row(children: [
-                Expanded(child: _payModeButton(context, PaymentMode.cash, 'Cash', Icons.payments)),
-                const SizedBox(width: 8),
-                Expanded(child: _payModeButton(context, PaymentMode.upi, 'UPI', Icons.qr_code)),
-                const SizedBox(width: 8),
-                Expanded(child: _payModeButton(context, PaymentMode.card, 'Card', Icons.credit_card)),
-              ]),
-              const SizedBox(height: 10),
-              Row(
-                children: [
-                  InkWell(
-                    onTap: onQuickPrint,
-                    borderRadius: BorderRadius.circular(24),
-                    child: const Padding(
-                      padding: EdgeInsets.all(6.0),
-                      child: Icon(Icons.print),
-                    ),
-                  ),
-                  const SizedBox(width: 4),
-                  Expanded(
-                    child: ElevatedButton.icon(
-                      onPressed: onCheckout,
-                      icon: const Icon(Icons.check_circle),
-                      label: const Text('Checkout'),
-                    ),
-                  ),
-                ],
-              ),
-            ],
-          ),
-        ),
+        child: content,
       ),
     );
   }
-
   Widget _payModeButton(BuildContext context, PaymentMode mode, String label, IconData icon) {
-    final selected = selectedPaymentMode == mode;
+    final selected = widget.selectedPaymentMode == mode;
     return OutlinedButton.icon(
-      onPressed: () => onPaymentModeChanged(mode),
+      onPressed: () {
+        if (mode == PaymentMode.credit) {
+          // Leave field blank per new UX (no auto-populate)
+          _creditAmountCtrl.text = '';
+        }
+        widget.onPaymentModeChanged(mode);
+      },
       icon: Icon(icon, color: selected ? Theme.of(context).colorScheme.primary : null),
       label: Text(label),
       style: OutlinedButton.styleFrom(
@@ -143,32 +220,179 @@ class CheckoutPanel extends StatelessWidget {
       ),
     );
   }
-
   Widget _kv(String label, double value, {bool bold = false}) {
     final style = TextStyle(fontWeight: bold ? FontWeight.bold : FontWeight.normal);
     return Padding(
       padding: const EdgeInsets.symmetric(vertical: 2.0),
-      child: Row(
-        mainAxisAlignment: MainAxisAlignment.spaceBetween,
-        children: [Text(label, style: style), Text('₹${value.toStringAsFixed(2)}', style: style)],
-      ),
+      child: Row(mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
+        Text(label, style: style),
+        Text('₹${value.toStringAsFixed(2)}', style: style),
+      ]),
+    );
+  }
+  Future<void> _openPrintSettings(BuildContext context) async {
+    final ps = globalPrintSettings;
+    int tempWidth = ps.receiptCharWidth;
+    int tempPaperMm = ps.paperWidthMm;
+    int tempFontSize = ps.fontSizePt;
+    PaperSize tempSize = ps.paperSize;
+    PageOrientation tempOrientation = ps.orientation;
+    bool tempScale = ps.scaleToFit;
+    await showDialog(
+      context: context,
+      builder: (ctx) => StatefulBuilder(builder: (ctx, setLocal) {
+        int previewWidth = tempScale && tempSize == PaperSize.receipt ? _deriveCharWidth(tempPaperMm) : tempWidth;
+        return AlertDialog(
+          title: const Text('Print Settings'),
+          content: SizedBox(
+            width: 380,
+            child: Column(mainAxisSize: MainAxisSize.min, children: [
+              Row(children: [
+                const Text('Paper:'), const SizedBox(width: 8),
+                DropdownButton<PaperSize>(
+                  value: tempSize,
+                  items: const [
+                    DropdownMenuItem(value: PaperSize.receipt, child: Text('Receipt (Thermal)')),
+                    DropdownMenuItem(value: PaperSize.a4, child: Text('A4')),
+                  ],
+                  onChanged: (v) { if (v != null) setLocal(() => tempSize = v); },
+                ),
+              ]),
+              const SizedBox(height: 8),
+              Row(children: [
+                const Text('Orientation:'), const SizedBox(width: 8),
+                DropdownButton<PageOrientation>(
+                  value: tempOrientation,
+                  items: const [
+                    DropdownMenuItem(value: PageOrientation.portrait, child: Text('Portrait')),
+                    DropdownMenuItem(value: PageOrientation.landscape, child: Text('Landscape')),
+                  ],
+                  onChanged: tempSize == PaperSize.receipt ? null : (v) { if (v != null) setLocal(() => tempOrientation = v); },
+                ),
+              ]),
+              if (tempSize == PaperSize.receipt) const SizedBox(height: 8),
+              if (tempSize == PaperSize.receipt) Row(children: [
+                const Text('Width (mm):'), const SizedBox(width: 8),
+                DropdownButton<int>(
+                  value: tempPaperMm,
+                  items: const [
+                    DropdownMenuItem(value: 48, child: Text('48 mm')),
+                    DropdownMenuItem(value: 58, child: Text('58 mm')),
+                    DropdownMenuItem(value: 80, child: Text('80 mm')),
+                  ],
+                  onChanged: (v) { if (v != null) setLocal(() => tempPaperMm = v); },
+                ),
+              ]),
+              const SizedBox(height: 8),
+              SwitchListTile(
+                contentPadding: EdgeInsets.zero,
+                title: const Text('Auto scale to paper width'),
+                value: tempScale,
+                onChanged: (v) => setLocal(() => tempScale = v),
+              ),
+              const SizedBox(height: 8),
+              Row(children: [
+                const Text('Font size:'), const SizedBox(width: 8),
+                Expanded(
+                  child: Slider(
+                    min: 6,
+                    max: 24,
+                    divisions: 18,
+                    value: tempFontSize.toDouble(),
+                    label: '${tempFontSize}pt',
+                    onChanged: (v) => setLocal(() => tempFontSize = v.round()),
+                  ),
+                ),
+                SizedBox(width: 40, child: Text('${tempFontSize}pt', textAlign: TextAlign.right, style: const TextStyle(fontSize: 12)))
+              ]),
+              const SizedBox(height: 8),
+              if (tempSize == PaperSize.receipt && !tempScale) Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
+                const Text('Receipt Character Width'),
+                Slider(
+                  min: 20,
+                  max: 80,
+                  divisions: 60,
+                  value: tempWidth.toDouble(),
+                  label: '$tempWidth',
+                  onChanged: (v) => setLocal(() => tempWidth = v.round()),
+                ),
+              ]),
+              const SizedBox(height: 4),
+              Align(
+                alignment: Alignment.centerLeft,
+                child: Text('Preview width: $previewWidth chars • Font ${tempFontSize}pt (${tempSize == PaperSize.receipt ? '${tempPaperMm}mm' : 'A4'})', style: const TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),
+              )
+            ]),
+          ),
+          actions: [
+            TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
+            ElevatedButton(onPressed: () {
+              ps.update(
+                paperSize: tempSize,
+                orientation: tempOrientation,
+                scaleToFit: tempScale,
+                receiptCharWidth: tempWidth,
+                paperWidthMm: tempPaperMm,
+                fontSizePt: tempFontSize,
+              );
+              Navigator.pop(ctx);
+            }, child: const Text('Save')),
+          ],
+        );
+      }),
     );
   }
+  int _deriveCharWidth(int mm) {
+    if (mm <= 50) return 32;
+    if (mm <= 60) return 40;
+    if (mm <= 72) return 48;
+    if (mm <= 86) return 56;
+    return 64;
+  }
 }
 
-class _CustomerInfo extends StatelessWidget {
-  final Customer? selected;
-  const _CustomerInfo({required this.selected});
-  String _fmtPts(double v) {
-    final s = v.toStringAsFixed(1);
-    return s.endsWith('.0') ? s.substring(0, s.length - 2) : s;
+class _CreditPreview extends StatelessWidget {
+  final double entered;
+  final double payable;
+  final double existingCredit;
+  const _CreditPreview({required this.entered, required this.payable, required this.existingCredit});
+
+  @override
+  Widget build(BuildContext context) {
+    if (entered < 0) return const SizedBox.shrink();
+    double addPortion = 0;
+    double repayPortion = 0;
+    if (entered >= payable) {
+      final excess = entered - payable;
+      repayPortion = excess.clamp(0, existingCredit);
+    } else {
+      addPortion = (payable - entered).clamp(0, double.infinity);
+    }
+    final theme = Theme.of(context);
+    final style = theme.textTheme.bodySmall;
+    String msg;
+    if (addPortion > 0) {
+      msg = 'Will ADD credit: ₹${addPortion.toStringAsFixed(2)} (Customer owes more)';
+    } else if (repayPortion > 0) {
+      msg = 'Will REPAY old credit: ₹${repayPortion.toStringAsFixed(2)}';
+    } else {
+      msg = 'Fully paid — no credit change';
+    }
+    return Align(
+      alignment: Alignment.centerLeft,
+      child: Text(msg, style: style?.copyWith(color: theme.colorScheme.secondary)),
+    );
   }
+}
+
+class _CustomerInfo extends StatelessWidget {
+  final Customer? selected; final bool creditActive;
+  const _CustomerInfo({required this.selected, this.creditActive = false});
+  String _fmtPts(double v) { final s = v.toStringAsFixed(1); return s.endsWith('.0') ? s.substring(0, s.length - 2) : s; }
   @override
   Widget build(BuildContext context) {
-    final c = selected;
-    if (c == null || c.id.isEmpty) return const SizedBox();
-    String planLabel = (c.status ?? 'standard');
-    planLabel = planLabel[0].toUpperCase() + planLabel.substring(1);
+    final c = selected; if (c == null || c.id.isEmpty) return const SizedBox();
+    String planLabel = (c.status ?? 'standard'); planLabel = planLabel[0].toUpperCase() + planLabel.substring(1);
     return Container(
       width: double.infinity,
       margin: const EdgeInsets.only(bottom: 8),
@@ -177,262 +401,273 @@ class _CustomerInfo extends StatelessWidget {
         color: Theme.of(context).colorScheme.surfaceContainerHighest.withValues(alpha: 0.4),
         borderRadius: BorderRadius.circular(6),
       ),
-      child: Column(
-        crossAxisAlignment: CrossAxisAlignment.start,
-        children: [
-          Text(c.name, style: const TextStyle(fontWeight: FontWeight.bold)),
-          if (c.email != null && c.email!.isNotEmpty)
-            Text(c.email!, style: const TextStyle(fontSize: 12)),
-          const SizedBox(height: 4),
-          Wrap(spacing: 12, runSpacing: 4, children: [
-            _miniInfoChip(context, Icons.workspace_premium, 'Plan: $planLabel'),
-            _miniInfoChip(context, Icons.percent, 'Discount: ${c.discountPercent.toStringAsFixed(0)}%'),
-            _miniInfoChip(context, Icons.card_giftcard, 'Rewards: ${_fmtPts(c.rewardsPoints)}'),
-            _miniInfoChip(context, Icons.account_balance_wallet, 'Spend: ₹${c.totalSpend.toStringAsFixed(0)}'),
-          ]),
-        ],
-      ),
-    );
-  }
-
-  Widget _miniInfoChip(BuildContext context, IconData icon, String text) {
-    return Container(
-      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
-      decoration: BoxDecoration(
-        color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.08),
-        borderRadius: BorderRadius.circular(24),
-        border: Border.all(color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.3)),
-      ),
-      child: Row(
-        mainAxisSize: MainAxisSize.min,
-        children: [
-          Icon(icon, size: 14, color: Theme.of(context).colorScheme.primary),
-          const SizedBox(width: 4),
-          Text(text, style: const TextStyle(fontSize: 11)),
-        ],
-      ),
+      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
+        Text(c.name, style: const TextStyle(fontWeight: FontWeight.bold)),
+        if (c.email != null && c.email!.isNotEmpty) Text(c.email!, style: const TextStyle(fontSize: 12)),
+        const SizedBox(height: 4),
+        Wrap(spacing: 12, runSpacing: 4, children: [
+          _miniInfoChip(context, Icons.workspace_premium, 'Plan: $planLabel'),
+          _miniInfoChip(context, Icons.percent, 'Discount: ${c.discountPercent.toStringAsFixed(0)}%'),
+          _miniInfoChip(context, Icons.card_giftcard, 'Rewards: ${_fmtPts(c.rewardsPoints)}'),
+          _miniInfoChip(context, Icons.account_balance_wallet, 'Spend: ₹${c.totalSpend.toStringAsFixed(0)}'),
+          if (c.creditBalance > 0 || creditActive)
+            _miniInfoChip(context, Icons.receipt_long, 'Credit: ₹${c.creditBalance.toStringAsFixed(0)}'),
+        ])
+      ]),
     );
   }
+  Widget _miniInfoChip(BuildContext context, IconData icon, String text) => Container(
+    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
+    decoration: BoxDecoration(
+      color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.08),
+      borderRadius: BorderRadius.circular(24),
+      border: Border.all(color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.3)),
+    ),
+    child: Row(mainAxisSize: MainAxisSize.min, children: [
+      Icon(icon, size: 14, color: Theme.of(context).colorScheme.primary), const SizedBox(width: 4), Text(text, style: const TextStyle(fontSize: 11)),
+    ]),
+  );
 }
 
+// _PayCreditButton removed (repayment flow simplified)
+
 class _RedeemSection extends StatelessWidget {
-  final TextEditingController controller;
-  final double availablePoints;
-  final double redeemedPoints;
-  final double redeemValue;
-  final VoidCallback onChange;
-  final VoidCallback onMax;
-  const _RedeemSection({
-    required this.controller,
-    required this.availablePoints,
-    required this.redeemValue,
-    required this.onChange,
-    required this.onMax,
-    required this.redeemedPoints,
-  });
+  final TextEditingController controller; final double availablePoints; final double redeemedPoints; final double redeemValue; final VoidCallback onChange; final VoidCallback onMax;
+  const _RedeemSection({required this.controller, required this.availablePoints, required this.redeemValue, required this.onChange, required this.onMax, required this.redeemedPoints});
   @override
   Widget build(BuildContext context) {
-    final entered = redeemedPoints;
-    final over = entered > availablePoints;
-    final negative = entered < 0;
-    String? errorText;
-    if (negative) {
-      errorText = 'Cannot be negative';
-    } else if (over) {
-      errorText = 'Not enough points (Avail: ${availablePoints.toStringAsFixed(0)})';
-    }
-    final helper = (!over && !negative && redeemValue > 0)
-        ? 'Value: ₹${redeemValue.toStringAsFixed(2)}'
-        : (!over && !negative ? 'Enter points to redeem' : null);
-    return Column(
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        const SizedBox(height: 8),
-        Row(children: [
-          Expanded(
-            child: TextField(
-              controller: controller,
-              decoration: InputDecoration(
-                labelText: 'Redeem Points',
-                prefixIcon: const Icon(Icons.card_giftcard),
-                helperText: helper,
-                errorText: errorText,
-                suffixIcon: (availablePoints > 0)
-                    ? Tooltip(
-                        message: 'Available: ${availablePoints.toStringAsFixed(0)}',
-                        child: Padding(
-                          padding: const EdgeInsets.only(right: 8.0),
-                          child: Center(
-                            widthFactor: 1,
-                            child: Text(
-                              availablePoints.toStringAsFixed(0),
-                              style: const TextStyle(fontSize: 11, fontWeight: FontWeight.w600),
-                            ),
-                          ),
-                        ),
-                      )
-                    : null,
-              ),
-              keyboardType: const TextInputType.numberWithOptions(decimal: true),
-              onChanged: (_) => onChange(),
-            ),
-          ),
-          const SizedBox(width: 8),
-          ElevatedButton(
-            onPressed: availablePoints <= 0 ? null : onMax,
-            child: const Text('Max'),
+    final entered = redeemedPoints; final over = entered > availablePoints; final negative = entered < 0;
+    String? errorText; if (negative) { errorText = 'Cannot be negative'; } else if (over) { errorText = 'Not enough points (Avail: ${availablePoints.toStringAsFixed(0)})'; }
+    final helper = (!over && !negative && redeemValue > 0) ? 'Value: ₹${redeemValue.toStringAsFixed(2)}' : (!over && !negative ? 'Enter points to redeem' : null);
+    return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
+      const SizedBox(height: 8),
+      Row(children: [
+        Expanded(child: TextField(
+          controller: controller,
+          decoration: InputDecoration(
+            labelText: 'Redeem Points',
+            prefixIcon: const Icon(Icons.card_giftcard),
+            helperText: helper,
+            errorText: errorText,
+            suffixIcon: (availablePoints > 0) ? Tooltip(message: 'Available: ${availablePoints.toStringAsFixed(0)}', child: Padding(padding: const EdgeInsets.only(right: 8.0), child: Center(widthFactor: 1, child: Text(availablePoints.toStringAsFixed(0), style: const TextStyle(fontSize: 11, fontWeight: FontWeight.w600))))) : null,
           ),
-        ]),
-      ],
-    );
+          keyboardType: const TextInputType.numberWithOptions(decimal: true),
+          onChanged: (_) => onChange(),
+        )),
+        const SizedBox(width: 8),
+        ElevatedButton(onPressed: availablePoints <= 0 ? null : onMax, child: const Text('Max')),
+      ])
+    ]);
   }
 }
 
-
 class _CustomerDropdown extends StatefulWidget {
-  final Stream<List<Customer>> customersStream;
-  final List<Customer> initialCustomers;
-  final Customer? selected;
-  final ValueChanged<Customer?> onSelected;
-  final Customer walkIn;
-  const _CustomerDropdown({
-    required this.customersStream,
-    required this.initialCustomers,
-    required this.selected,
-    required this.onSelected,
-    required this.walkIn,
-  });
-
+  final Stream<List<Customer>> customersStream; final List<Customer> initialCustomers; final Customer? selected; final ValueChanged<Customer?> onSelected; final Customer walkIn;
+  const _CustomerDropdown({required this.customersStream, required this.initialCustomers, required this.selected, required this.onSelected, required this.walkIn});
   @override
   State<_CustomerDropdown> createState() => _CustomerDropdownState();
 }
 
 class _CustomerDropdownState extends State<_CustomerDropdown> {
-  late List<Customer> _all;
-  bool _expanded = false;
-  final TextEditingController _searchCtrl = TextEditingController();
-  StreamSubscription<List<Customer>>? _sub;
-
+  late List<Customer> _all; bool _expanded = false; final TextEditingController _searchCtrl = TextEditingController(); StreamSubscription<List<Customer>>? _sub;
   @override
-  void initState() {
-    super.initState();
-    _all = [widget.walkIn, ...widget.initialCustomers];
-    _sub = widget.customersStream.listen((list) {
-      setState(() {
-        // Ensure walk-in at top (id empty or special) and remove duplicates by id
-        final byId = <String, Customer>{ for (final c in list) c.id : c };
-        _all = [widget.walkIn, ...byId.values.where((c) => c.id != widget.walkIn.id)];
-      });
-    });
-  }
-
+  void initState() { super.initState(); _all = [widget.walkIn, ...widget.initialCustomers]; _sub = widget.customersStream.listen((list) { setState(() { final byId = <String, Customer>{ for (final c in list) c.id : c }; _all = [widget.walkIn, ...byId.values.where((c) => c.id != widget.walkIn.id)]; }); }); }
   @override
-  void dispose() {
-    _sub?.cancel();
-    _searchCtrl.dispose();
-    super.dispose();
-  }
-
-  List<Customer> get _filtered {
-    final q = _searchCtrl.text.trim().toLowerCase();
-    if (q.isEmpty) return _all;
-    return _all.where((c) {
-      bool m(String? v) => v != null && v.toLowerCase().contains(q);
-      return m(c.name) || m(c.email) || m(c.phone);
-    }).toList();
-  }
-
+  void dispose() { _sub?.cancel(); _searchCtrl.dispose(); super.dispose(); }
+  List<Customer> get _filtered { final q = _searchCtrl.text.trim().toLowerCase(); if (q.isEmpty) return _all; return _all.where((c) { bool m(String? v) => v != null && v.toLowerCase().contains(q); return m(c.name) || m(c.email) || m(c.phone); }).toList(); }
   @override
   Widget build(BuildContext context) {
     final sel = widget.selected ?? widget.walkIn;
-    return Column(
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        InkWell(
-          onTap: () => setState(() => _expanded = !_expanded),
-          child: InputDecorator(
-            decoration: const InputDecoration(
-              labelText: 'Customer',
-              border: OutlineInputBorder(),
-              isDense: true,
-            ),
-            child: Row(
-              children: [
-                const Icon(Icons.person, size: 18),
-                const SizedBox(width: 6),
-                Expanded(child: Text(sel.name, overflow: TextOverflow.ellipsis)),
-                Icon(_expanded ? Icons.expand_less : Icons.expand_more),
-              ],
+    return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
+      InkWell(
+        onTap: () => setState(() => _expanded = !_expanded),
+        child: InputDecorator(
+          decoration: const InputDecoration(labelText: 'Customer', border: OutlineInputBorder(), isDense: true),
+          child: Row(children: [
+            const Icon(Icons.person, size: 18), const SizedBox(width: 6), Expanded(child: Text(sel.name, overflow: TextOverflow.ellipsis)),
+            IconButton(
+              tooltip: 'Add Customer',
+              padding: EdgeInsets.zero,
+              constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
+              icon: const Icon(Icons.add_circle_outline, size: 20),
+              onPressed: () async {
+                final created = await _showAddCustomerDialog(context);
+                if (created != null) { widget.onSelected(created); if (!mounted) return; setState(() { _expanded = false; }); }
+              },
             ),
-          ),
+            const SizedBox(width: 4),
+            Icon(_expanded ? Icons.expand_less : Icons.expand_more),
+          ]),
         ),
-        AnimatedSwitcher(
-          duration: const Duration(milliseconds: 200),
-          child: _expanded
-              ? Container(
-                  key: const ValueKey('dd'),
-                  margin: const EdgeInsets.only(top: 4),
-                  decoration: BoxDecoration(
-                    border: Border.all(color: Theme.of(context).dividerColor),
-                    borderRadius: BorderRadius.circular(6),
-                    color: Theme.of(context).colorScheme.surfaceContainerHighest.withValues(alpha: 0.3),
-                  ),
+      ),
+      AnimatedSwitcher(
+        duration: const Duration(milliseconds: 200),
+        child: _expanded ? Container(
+          key: const ValueKey('dd'),
+          margin: const EdgeInsets.only(top: 4),
+          decoration: BoxDecoration(
+            border: Border.all(color: Theme.of(context).dividerColor),
+            borderRadius: BorderRadius.circular(6),
+            color: Theme.of(context).colorScheme.surfaceContainerHighest.withValues(alpha: 0.3),
+          ),
+          child: Column(children: [
+            Padding(
+              padding: const EdgeInsets.fromLTRB(8, 8, 8, 4),
+              child: TextField(
+                controller: _searchCtrl,
+                decoration: const InputDecoration(prefixIcon: Icon(Icons.search), hintText: 'Search name / email / phone', isDense: true, border: OutlineInputBorder()),
+                onChanged: (_) => setState(() {}),
+              ),
+            ),
+            const Divider(height: 1),
+            ConstrainedBox(
+              constraints: const BoxConstraints(maxHeight: 260),
+              child: _filtered.isEmpty ? const Padding(padding: EdgeInsets.all(16.0), child: Text('No customers')) : ListView.separated(
+                shrinkWrap: true,
+                itemCount: _filtered.length,
+                separatorBuilder: (_, __) => const Divider(height: 1),
+                itemBuilder: (_, i) {
+                  final c = _filtered[i]; final isSel = c.id == sel.id;
+                  return ListTile(
+                    dense: true,
+                    leading: isSel ? Icon(Icons.check_circle, color: Theme.of(context).colorScheme.primary) : const Icon(Icons.person_outline),
+                    title: Text(c.name),
+                    subtitle: (c.email != null && c.email!.isNotEmpty) ? Text(c.email!, style: const TextStyle(fontSize: 11)) : null,
+                    onTap: () { widget.onSelected(c.id.isEmpty ? null : c); setState(() { _expanded = false; _searchCtrl.clear(); }); },
+                  );
+                },
+              ),
+            ),
+          ]),
+        ) : const SizedBox.shrink(),
+      ),
+    ]);
+  }
+  Future<Customer?> _showAddCustomerDialog(BuildContext context) async {
+    final nameCtrl = TextEditingController();
+    final emailCtrl = TextEditingController();
+    final phoneCtrl = TextEditingController();
+    final addrCtrl = TextEditingController();
+    final formKey = GlobalKey<FormState>();
+    bool saving = false;
+    // Capture messenger early to avoid using a possibly stale BuildContext after async gaps.
+    final messenger = ScaffoldMessenger.of(context);
+    final created = await showDialog<Customer?>(
+      context: context,
+      barrierDismissible: false,
+      builder: (ctx) => StatefulBuilder(
+        builder: (ctx, setLocal) {
+          return AlertDialog(
+            title: const Text('Add Customer'),
+            content: SizedBox(
+              width: 420,
+              child: Form(
+                key: formKey,
+                child: SingleChildScrollView(
                   child: Column(
+                    mainAxisSize: MainAxisSize.min,
                     children: [
-                      Padding(
-                        padding: const EdgeInsets.fromLTRB(8, 8, 8, 4),
-                        child: TextField(
-                          controller: _searchCtrl,
-                          decoration: const InputDecoration(
-                            prefixIcon: Icon(Icons.search),
-                            hintText: 'Search name / email / phone',
-                            isDense: true,
-                            border: OutlineInputBorder(),
-                          ),
-                          onChanged: (_) => setState(() {}),
-                        ),
+                      TextFormField(
+                        controller: nameCtrl,
+                        decoration: const InputDecoration(labelText: 'Name *'),
+                        autofocus: true,
+                        validator: (v) => (v==null || v.trim().isEmpty) ? 'Name required' : null,
+                      ),
+                      TextFormField(
+                        controller: emailCtrl,
+                        decoration: const InputDecoration(labelText: 'Email'),
+                        keyboardType: TextInputType.emailAddress,
+                      ),
+                      TextFormField(
+                        controller: phoneCtrl,
+                        decoration: const InputDecoration(labelText: 'Phone'),
+                        keyboardType: TextInputType.phone,
                       ),
-                      const Divider(height: 1),
-                      ConstrainedBox(
-                        constraints: const BoxConstraints(maxHeight: 260),
-                        child: _filtered.isEmpty
-                            ? const Padding(
-                                padding: EdgeInsets.all(16.0),
-                                child: Text('No customers'),
-                              )
-                            : ListView.separated(
-                                shrinkWrap: true,
-                                itemCount: _filtered.length,
-                                separatorBuilder: (_, __) => const Divider(height: 1),
-                                itemBuilder: (_, i) {
-                                  final c = _filtered[i];
-                                  final isSel = c.id == sel.id;
-                                  return ListTile(
-                                    dense: true,
-                                    leading: isSel
-                                        ? Icon(Icons.check_circle, color: Theme.of(context).colorScheme.primary)
-                                        : const Icon(Icons.person_outline),
-                                    title: Text(c.name),
-                                    subtitle: (c.email != null && c.email!.isNotEmpty)
-                                        ? Text(c.email!, style: const TextStyle(fontSize: 11))
-                                        : null,
-                                    onTap: () {
-                                      widget.onSelected(c.id.isEmpty ? null : c);
-                                      setState(() {
-                                        _expanded = false;
-                                        _searchCtrl.clear();
-                                      });
-                                    },
-                                  );
-                                },
-                              ),
+                      TextFormField(
+                        controller: addrCtrl,
+                        decoration: const InputDecoration(labelText: 'Address'),
+                        minLines: 2,
+                        maxLines: 3,
                       ),
                     ],
                   ),
-                )
-              : const SizedBox.shrink(),
-        ),
-      ],
+                ),
+              ),
+            ),
+            actions: [
+              TextButton(
+                onPressed: saving ? null : () => Navigator.pop(ctx, null),
+                child: const Text('Close'),
+              ),
+              FilledButton.icon(
+                onPressed: saving ? null : () async {
+                  if (!formKey.currentState!.validate()) return;
+                  setLocal(() => saving = true);
+                  try {
+                    final name = nameCtrl.text.trim();
+                    final data = <String, dynamic>{
+                      'name': name,
+                      'email': emailCtrl.text.trim(),
+                      'phone': phoneCtrl.text.trim(),
+                      'address': addrCtrl.text.trim(),
+                      'createdAt': FieldValue.serverTimestamp(),
+                      'totalSpend': 0,
+                      'loyaltyPoints': 0,
+                    };
+                    final doc = await FirebaseFirestore.instance.collection('customers').add(data);
+                    final newCustomer = Customer(
+                      id: doc.id,
+                      name: name.isEmpty ? 'Unnamed' : name,
+                      email: emailCtrl.text.trim().isEmpty ? null : emailCtrl.text.trim(),
+                       phone: phoneCtrl.text.trim().isEmpty ? null : phoneCtrl.text.trim(),
+                      status: null,
+                      totalSpend: 0,
+                      rewardsPoints: 0,
+                      discountPercent: 0,
+                      creditBalance: 0,
+                    );
+                    Navigator.pop(ctx, newCustomer);
+                  } catch (e) {
+                    if (kDebugMode) debugPrint('Add customer failed: $e');
+                    messenger.showSnackBar(
+                      SnackBar(content: Text('Failed: $e')),
+                    );
+                  } finally {
+                    // Only reset state if the dialog is still visible and we haven't popped.
+                    if (saving && Navigator.of(ctx).mounted) {
+                      // If we reached here after an error (no pop) keep dialog enabled again.
+                      if (mounted && Navigator.of(ctx).canPop()) {
+                        setLocal(() => saving = false);
+                      }
+                    }
+                  }
+                },
+                icon: saving
+                    ? const SizedBox(
+                        width: 16,
+                        height: 16,
+                        child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
+                      )
+                    : const Icon(Icons.save),
+                label: Text(saving ? 'Saving...' : 'Save'),
+              ),
+            ],
+          );
+        },
+      ),
     );
+    // Dispose controllers
+    nameCtrl.dispose();
+    emailCtrl.dispose();
+    phoneCtrl.dispose();
+    addrCtrl.dispose();
+    if (created != null && mounted) {
+      setState(() {
+        if (!_all.any((c) => c.id == created.id)) {
+          _all.add(created);
+        }
+      });
+    }
+    return created;
   }
 }
diff --git a/lib/modules/pos/pos_ui.dart b/lib/modules/pos/pos_ui.dart
index 952e643..d65af9b 100644
--- a/lib/modules/pos/pos_ui.dart
+++ b/lib/modules/pos/pos_ui.dart
@@ -3,14 +3,15 @@
 // Models & enums live in pos.dart to allow reuse without pulling in UI code.
 
 import 'dart:async';
+import 'dart:convert';
 
 import 'package:cloud_firestore/cloud_firestore.dart';
+import 'package:firebase_auth/firebase_auth.dart';
+import 'package:firebase_core/firebase_core.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter/services.dart';
 import 'package:flutter/foundation.dart';
 import 'package:http/http.dart' as http;
-import 'package:pdf/pdf.dart';
-import 'package:pdf/widgets.dart' as pw;
 
 import 'invoice_models.dart';
 import 'invoice_pdf.dart'; // For PDF generation (email attachment only; download removed)
@@ -19,6 +20,22 @@ import 'pos.dart'; // models & enums
 import 'pos_search_scan_fav.dart';
 import '../inventory/inventory_repository.dart';
 import 'pos_checkout.dart';
+import 'credit_service.dart';
+import 'backend_launcher_stub.dart' if (dart.library.io) 'backend_launcher_desktop.dart';
+import 'windows_print_stub.dart' if (dart.library.io) 'windows_print.dart';
+import 'web_print_fallback_stub.dart' if (dart.library.js) 'web_print_fallback.dart';
+
+// Debug/feature flags (set with --dart-define=KEY=value)
+const bool kDisableInvoiceWrites = bool.fromEnvironment('DISABLE_INVOICE_WRITES', defaultValue: false);
+const bool kDisableLoyaltyTx = bool.fromEnvironment('DISABLE_LOYALTY_TX', defaultValue: false);
+const bool kPosVerbose = bool.fromEnvironment('POS_DEBUG_VERBOSE', defaultValue: false);
+const bool kSafeWindowsSkipFirestore = bool.fromEnvironment('SAFE_WINDOWS_SKIP_FIRESTORE', defaultValue: true); // default true until crash source isolated
+// Enable or disable direct hidden PowerShell printing on Windows (fallback / alternative to backend service)
+const bool kEnableDirectPsPrint = bool.fromEnvironment('ENABLE_DIRECT_PS_PRINT', defaultValue: true);
+// Web: if true, open the browser's print dialog; if false, send to backend silently
+const bool kWebOpenBrowserPrint = bool.fromEnvironment('WEB_OPEN_BROWSER_PRINT', defaultValue: false);
+// Web strict-silent: when true, never open browser print dialog (no fallback); fail with a message instead
+const bool kWebStrictSilent = bool.fromEnvironment('WEB_STRICT_SILENT', defaultValue: false);
 
 class PosPage extends StatefulWidget {
   const PosPage({super.key});
@@ -61,8 +78,7 @@ class _PosPageState extends State<PosPage> {
   final TextEditingController _redeemPointsCtrl = TextEditingController(text: '0');
   double _availablePoints = 0; // loaded from customer doc when selected
   static const double _pointValue = 1; // 1 point = ₹1 (adjust if needed or load from settings)
-  // Scroll controller for summary/payment panel (enables scrollbar & prevents overflow)
-  final ScrollController _summaryScrollCtrl = ScrollController();
+  // Scrollbar for summary panel now managed inside CheckoutPanel; local controller removed.
   // Active subscription to currently selected customer's document for live loyalty point updates
   StreamSubscription<DocumentSnapshot<Map<String, dynamic>>>? _customerDocSub;
 
@@ -86,6 +102,8 @@ class _PosPageState extends State<PosPage> {
   void initState() {
     super.initState();
     _backendBase = _resolveBackendBase();
+  // On Windows desktop attempt to auto-start backend if not reachable.
+  ensurePrinterBackendRunning();
     selectedCustomer = customers.first;
     // Fix discount mode to Percent (discount type selector removed)
     discountType = DiscountType.percent;
@@ -106,83 +124,42 @@ class _PosPageState extends State<PosPage> {
     const envUrl = String.fromEnvironment('PRINTER_BACKEND_URL', defaultValue: '');
     if (envUrl.isNotEmpty) return envUrl;
     if (kIsWeb) {
-      final scheme = Uri.base.scheme == 'https' ? 'https' : 'http';
+      // If the app is served over HTTPS and no explicit backend URL is provided,
+      // do NOT default to https://host:5005 (likely not available). Leave empty to force fallback.
+      if (Uri.base.scheme == 'https') {
+        return '';
+      }
       final host = Uri.base.host.isEmpty ? 'localhost' : Uri.base.host;
       const port = 5005;
-      return '$scheme://$host:$port';
+      return 'http://$host:$port';
     }
     return 'http://localhost:5005';
   }
 
-  Future<void> _loadCustomersOnce() async {
-    try {
-      final first = await _customerStream.first;
-      if (mounted) {
-        setState(() {
-          customers = first;
-          if (!customers.contains(selectedCustomer)) {
-            selectedCustomer = customers.first;
-          }
-        });
-      }
-    } catch (_) {
-      // ignore failures; UI will still use stream builder later
-    }
-  }
-
-  @override
-  void dispose() {
-    _finalizeTimer?.cancel();
-    _customerDocSub?.cancel();
-    _scannerFocusNode.dispose();
-    barcodeCtrl.dispose();
-    searchCtrl.dispose();
-    customerSearchCtrl.dispose();
-    discountCtrl.dispose();
-    _redeemPointsCtrl.dispose();
-    _summaryScrollCtrl.dispose();
-    super.dispose();
-  }
+  bool get _canUseBackend => _backendBase.isNotEmpty;
 
-  // Stream CRM customers from Firestore `customers` collection
+  // Live stream of CRM customers from Firestore
   Stream<List<Customer>> get _customerStream => FirebaseFirestore.instance
       .collection('customers')
       .snapshots()
-      .map((snap) {
-        final list = snap.docs.map((d) => Customer.fromDoc(d)).toList();
-        list.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
-        return [walkIn, ...list];
-      });
-
-  // Print Settings UI removed; printing now sends to backend default printer.
-  Future<void> _quickPrintFromPanel() async {
-    if (_isPrinting) return;
-    await _oneClickPrintCurrentCart();
-  }
+      .map((s) {
+    final list = s.docs.map((d) => Customer.fromDoc(d)).toList();
+    list.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
+    return list;
+  });
 
-  Future<void> _oneClickPrintCurrentCart() async {
-    if (cart.isEmpty) {
-      _snack('Cart empty');
-      return;
-    }
-    setState(() => _isPrinting = true);
+  Future<void> _loadCustomersOnce() async {
     try {
-      final invoice = _buildTempInvoiceForPrint();
-      final pdfBytes = await _buildThermalPdf(invoice, widthMm: 48, marginMm: 4, density: 8);
-      final uri = Uri.parse('$_backendBase/print-pdf');
-      final req = http.MultipartRequest('POST', uri)
-        ..files.add(http.MultipartFile.fromBytes('file', pdfBytes, filename: 'pos_receipt.pdf'));
-      final streamed = await req.send();
-      final resp = await http.Response.fromStream(streamed);
-      if (resp.statusCode == 200) {
-        _snack('Printed');
-      } else {
-        _snack('Print failed: ${resp.statusCode}');
-      }
+      final first = await _customerStream.first;
+      if (!mounted) return;
+      setState(() {
+        customers = [walkIn, ...first.where((c) => c.id != walkIn.id)];
+        if (!customers.any((c) => c.id == (selectedCustomer?.id ?? ''))) {
+          selectedCustomer = customers.first;
+        }
+      });
     } catch (e) {
-      _snack('Print error: $e');
-    } finally {
-      if (mounted) setState(() => _isPrinting = false);
+      if (kPosVerbose) debugPrint('[POS] customers preload failed: $e');
     }
   }
 
@@ -232,49 +209,92 @@ class _PosPageState extends State<PosPage> {
     );
   }
 
-  Future<Uint8List> _buildThermalPdf(InvoiceData data, {double widthMm = 48, double marginMm = 4, int density = 8}) async {
-    final doc = pw.Document();
-    final fmtDate = '${data.timestamp.year.toString().padLeft(4,'0')}-${data.timestamp.month.toString().padLeft(2,'0')}-${data.timestamp.day.toString().padLeft(2,'0')}';
-    final fmtTime = '${data.timestamp.hour.toString().padLeft(2,'0')}:${data.timestamp.minute.toString().padLeft(2,'0')}:${data.timestamp.second.toString().padLeft(2,'0')}';
-    final pageFormat = PdfPageFormat(widthMm * PdfPageFormat.mm, double.maxFinite, marginAll: marginMm * PdfPageFormat.mm);
-    doc.addPage(pw.MultiPage(
-      pageFormat: pageFormat,
-      build: (ctx) {
-        final widgets = <pw.Widget>[];
-        widgets.add(pw.Center(child: pw.Text('RECEIPT', style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold))));
-        widgets.add(pw.SizedBox(height: 4));
-        widgets.add(pw.Text('No: ${data.invoiceNumber}', style: const pw.TextStyle(fontSize: 8)));
-        widgets.add(pw.Text('Date: $fmtDate $fmtTime', style: const pw.TextStyle(fontSize: 8)));
-        widgets.add(pw.Text('Cust: ${data.customerName}', style: const pw.TextStyle(fontSize: 8)));
-        if ((data.customerPhone ?? '').isNotEmpty) widgets.add(pw.Text('Ph: ${data.customerPhone}', style: const pw.TextStyle(fontSize: 8)));
-        widgets.add(pw.Divider());
-        for (final l in data.lines) {
-          widgets.add(pw.Row(children:[
-            pw.Expanded(child: pw.Text(l.name, style: const pw.TextStyle(fontSize: 8))),
-            pw.Text('x${l.qty}', style: const pw.TextStyle(fontSize: 8)),
-          ]));
-          widgets.add(pw.Row(mainAxisAlignment: pw.MainAxisAlignment.spaceBetween, children:[
-            pw.Text('₹${l.unitPrice.toStringAsFixed(2)}', style: const pw.TextStyle(fontSize: 8)),
-            if (l.discount>0) pw.Text('-${l.discount.toStringAsFixed(2)}', style: const pw.TextStyle(fontSize: 8)),
-            pw.Text('₹${l.lineTotal.toStringAsFixed(2)}', style: const pw.TextStyle(fontSize: 8)),
-          ]));
+  // One-click print from the right panel without creating an invoice record.
+  Future<void> _quickPrintFromPanel() async {
+    if (cart.isEmpty) return _snack('Cart empty');
+    if (_isPrinting) return;
+    setState(() => _isPrinting = true);
+    try {
+      final invoice = _buildTempInvoiceForPrint();
+      bool directOk = false;
+      if (kEnableDirectPsPrint) {
+        try {
+          directOk = await directWindowsPrintInvoice(invoice);
+        } catch (_) {
+          directOk = false;
         }
-        widgets.add(pw.Divider());
-        pw.Widget kv(String k, String v,{bool b=false}) => pw.Row(mainAxisAlignment: pw.MainAxisAlignment.spaceBetween, children:[pw.Text(k,style: pw.TextStyle(fontSize:8,fontWeight:b?pw.FontWeight.bold:pw.FontWeight.normal)), pw.Text(v,style: pw.TextStyle(fontSize:8,fontWeight:b?pw.FontWeight.bold:pw.FontWeight.normal))]);
-        widgets.add(kv('Subtotal','₹${data.subtotal.toStringAsFixed(2)}'));
-        widgets.add(kv('Discount','-₹${data.discountTotal.toStringAsFixed(2)}'));
-        if (data.redeemedValue>0) widgets.add(kv('Redeemed','-₹${data.redeemedValue.toStringAsFixed(2)}'));
-        widgets.add(kv('GST','₹${data.taxTotal.toStringAsFixed(2)}'));
-        widgets.add(pw.Divider());
-        widgets.add(kv('TOTAL','₹${data.grandTotal.toStringAsFixed(2)}', b:true));
-        widgets.add(kv('Paid', data.paymentMode));
-        widgets.add(pw.SizedBox(height:4));
-        widgets.add(pw.Text('Thank you!', style: const pw.TextStyle(fontSize: 8)));
-        return widgets;
       }
-    ));
-    return doc.save();
+      if (directOk) {
+        _snack('Invoice sent to printer (direct)');
+        return;
+      }
+
+      if (kIsWeb) {
+        // Web: try backend if available, then always fall back to browser print.
+        bool backendOk = false;
+        if (_canUseBackend) {
+          try {
+            try {
+              await http.get(Uri.parse('$_backendBase/health')).timeout(const Duration(seconds: 2));
+            } catch (_) {}
+            final resp = await http.post(Uri.parse('$_backendBase/print-invoice'),
+                headers: {'Content-Type': 'application/json'},
+                body: jsonEncode({'invoice': invoice.toJson()}));
+            if (resp.statusCode == 200) {
+              backendOk = true;
+              try {
+                final data = jsonDecode(resp.body) as Map<String, dynamic>;
+                final msg = (data['message'] as String?) ?? 'Invoice print sent';
+                final usedPrinter = data['usedPrinter'];
+                _snack(usedPrinter != null ? '$msg (${usedPrinter.toString()})' : msg);
+              } catch (_) {
+                _snack('Invoice print sent');
+              }
+              return;
+            } else if (kPosVerbose) {
+              debugPrint('[POS] backend print failed: ${resp.statusCode} ${resp.body}');
+            }
+          } catch (e) {
+            if (kPosVerbose) debugPrint('[POS][web] quick print backend error: $e');
+          }
+        }
+        // Not printed via backend => try browser dialog unless strict silent is enabled
+        if (!backendOk) {
+          if (kWebStrictSilent) {
+            _snack('Silent print unavailable (backend offline)');
+          } else {
+            // Pre-open window synchronously (for popup blockers), then populate and print
+            final handle = webPrintPreopen();
+            final handled = await webPrintPopulateAndPrint(handle, invoice);
+            if (handled) {
+              _snack('Browser print opened');
+              return;
+            }
+            _snack('Print error (popup blocked?)');
+          }
+        }
+      } else {
+        // Non-web: use backend service
+        try {
+          try { await http.get(Uri.parse('$_backendBase/health')).timeout(const Duration(seconds: 2)); } catch (_) {}
+          final resp = await http.post(Uri.parse('$_backendBase/print-invoice'),
+              headers: {'Content-Type': 'application/json'},
+              body: jsonEncode({'invoice': invoice.toJson()}));
+          if (resp.statusCode == 200) {
+            _snack('Invoice print sent');
+          } else {
+            _snack('Print failed (${resp.statusCode})');
+          }
+        } catch (e) {
+          if (kPosVerbose) debugPrint('[POS] quick print error: $e');
+          _snack('Print error');
+        }
+      }
+    } finally {
+      if (mounted) setState(() => _isPrinting = false);
+    }
   }
+
   double get _customerPercent => selectedCustomer?.discountPercent ?? 0;
   double get discountValue {
     switch (discountType) {
@@ -328,8 +348,9 @@ class _PosPageState extends State<PosPage> {
     _holdController.resumeHeld(order);
   }
 
-  Future<void> completeSale() async {
+  Future<void> completeSale({double creditPaidInput = 0}) async {
     if (cart.isEmpty) return _snack('Cart is empty');
+    if (kPosVerbose) debugPrint('[POS] completeSale begin cartItems=${cart.length}');
     final rp = redeemedPoints;
     if (rp > _availablePoints) {
       _snack('You do not have enough points');
@@ -339,8 +360,12 @@ class _PosPageState extends State<PosPage> {
       return;
     }
 
+    // Update local stock snapshot (UI only)
     for (final item in cart.values) {
-      item.product.stock -= item.qty;
+      final newStock = item.product.stock - item.qty;
+      if (newStock >= 0) {
+        item.product.stock = newStock;
+      }
     }
 
     final discounts = lineDiscounts;
@@ -389,27 +414,122 @@ class _PosPageState extends State<PosPage> {
     );
     lastInvoice = invoice;
 
-    try {
-      final data = invoice.toJson();
-      await FirebaseFirestore.instance.collection('invoices').doc(invoice.invoiceNumber).set({
-        ...data,
-        'timestampMs': invoice.timestamp.millisecondsSinceEpoch,
-        'status': 'Paid',
-      });
-    } catch (e) {
-      // ignore persistence failure
+  final isWindows = !kIsWeb && defaultTargetPlatform == TargetPlatform.windows;
+  final skipWritesForPlatform = isWindows && kSafeWindowsSkipFirestore;
+  if (skipWritesForPlatform && kPosVerbose) debugPrint('[POS] Skipping Firestore invoice write on Windows (safe mode)');
+
+    // Determine credit mixing BEFORE invoice persistence (central helper ensures consistent math)
+    double creditAddPortion = 0;
+    double creditRepayPortion = 0;
+    double paidNow = 0;
+    double expectedNewCredit = selectedCustomer?.creditBalance ?? 0;
+    if (selectedPaymentMode == PaymentMode.credit) {
+      paidNow = creditPaidInput.clamp(0, double.infinity);
+      final existingCredit = selectedCustomer?.creditBalance ?? 0;
+      final mix = CustomerCreditService.computeCreditMix(
+        saleDue: payableTotal,
+        existingCredit: existingCredit,
+        paidNow: paidNow,
+      );
+      creditAddPortion = mix['add'] ?? 0;
+      creditRepayPortion = mix['repay'] ?? 0;
+      expectedNewCredit = mix['newCredit'] ?? existingCredit;
+      if (kPosVerbose) {
+        debugPrint('[POS][creditMix] compute due=$payableTotal existing=$existingCredit paid=$paidNow add=$creditAddPortion repay=$creditRepayPortion -> expectedNew=$expectedNewCredit');
+      }
     }
 
-    if (selectedCustomer != null && selectedCustomer!.id.isNotEmpty) {
+    if (!kDisableInvoiceWrites && !skipWritesForPlatform) {
       try {
-        await _applyLoyaltyRewardsForCustomer(invoice);
-      } catch (e) {
-        if (mounted) {
-          _snack('Loyalty update failed: $e');
+        final data = invoice.toJson();
+        if (kPosVerbose) debugPrint('[POS] writing invoice ${invoice.invoiceNumber}');
+        await FirebaseFirestore.instance.collection('invoices').doc(invoice.invoiceNumber).set({
+          ...data,
+          'timestampMs': invoice.timestamp.millisecondsSinceEpoch,
+          'status': (selectedPaymentMode == PaymentMode.credit && creditAddPortion > 0) ? 'on_credit' : 'Paid',
+          if (selectedPaymentMode == PaymentMode.credit)
+            'credit': {
+              'paidNow': paidNow,
+              'added': creditAddPortion,
+              'repaid': creditRepayPortion,
+            },
+        });
+        if (kPosVerbose) debugPrint('[POS] invoice write done');
+      } catch (e, st) {
+        if (kPosVerbose) debugPrint('[POS] invoice write error: $e\n$st');
+        // Non-fatal for POS flow
+      }
+    } else if (kPosVerbose) {
+      debugPrint('[POS] invoice writes disabled');
+      if (selectedPaymentMode == PaymentMode.credit) {
+        _snack('Invoice write skipped (debug mode) – credit still adjusting');
+      }
+    }
+
+    if (selectedPaymentMode == PaymentMode.credit) {
+      if (selectedCustomer == null || selectedCustomer!.id.isEmpty) {
+        _snack('Select a customer for credit checkout');
+      } else {
+        try {
+          await CustomerCreditService.ensureCreditField(selectedCustomer!.id);
+          if (kPosVerbose) {
+            debugPrint('[POS][creditMix] attempting adjust add=$creditAddPortion repay=$creditRepayPortion');
+          }
+          final creditResult = await CustomerCreditService.adjustForCheckout(
+            customerId: selectedCustomer!.id,
+            creditAdd: creditAddPortion,
+            creditRepay: creditRepayPortion,
+            invoiceNumber: invoice.invoiceNumber,
+          );
+          setState(() {
+            selectedCustomer = Customer(
+              id: selectedCustomer!.id,
+              name: selectedCustomer!.name,
+              email: selectedCustomer!.email,
+              phone: selectedCustomer!.phone,
+              status: selectedCustomer!.status,
+              totalSpend: selectedCustomer!.totalSpend,
+              discountPercent: selectedCustomer!.discountPercent,
+              creditBalance: creditResult.newBalance,
+            );
+          });
+          if (kPosVerbose) {
+            debugPrint('[POS][creditMix] txn result prev=${creditResult.previousBalance} new=${creditResult.newBalance} amountChanged=${creditResult.amountChanged} ledger=${creditResult.ledgerRecorded} type=${creditResult.type} expectedNew=$expectedNewCredit');
+            if ((creditResult.newBalance - expectedNewCredit).abs() > 0.01) {
+              debugPrint('[POS][creditMix][warn] mismatch expected=$expectedNewCredit actual=${creditResult.newBalance}');
+            }
+          }
+          if (creditAddPortion == 0 && creditRepayPortion == 0) {
+            _snack('Credit unchanged (fully paid) → Balance ₹${creditResult.newBalance.toStringAsFixed(2)}');
+          } else {
+            _snack('Credit updated (Add ₹${creditAddPortion.toStringAsFixed(2)}, Repay ₹${creditRepayPortion.toStringAsFixed(2)}) → Balance ₹${creditResult.newBalance.toStringAsFixed(2)}');
+          }
+        } on FirebaseException catch (e) {
+          _snack('Credit failed (${e.code})');
+          if (kPosVerbose) debugPrint('[POS][creditMix][error] FirebaseException ${e.code} ${e.message}');
+        } catch (e) {
+          _snack('Credit adjust failed: $e');
+          if (kPosVerbose) debugPrint('[POS][creditMix][error] $e');
         }
       }
     }
 
+  if (!kDisableLoyaltyTx && !skipWritesForPlatform && selectedCustomer != null && selectedCustomer!.id.isNotEmpty) {
+    try {
+      if (kPosVerbose) debugPrint('[POS] loyalty tx start for cust=${selectedCustomer!.id}');
+      await _applyLoyaltyRewardsForCustomer(invoice);
+      if (kPosVerbose) debugPrint('[POS] loyalty tx ok');
+    } catch (e, st) {
+      // This catch should normally never trigger because the method internally handles errors.
+      if (kPosVerbose) debugPrint('[POS][loyalty][outer-catch] $e\n$st');
+      if (mounted) {
+        _snack('Loyalty failed: $e');
+      }
+    }
+  } else if (kPosVerbose) {
+    debugPrint('[POS] loyalty transaction skipped');
+  }
+
     if (!mounted) return;
 
     final summary = _buildInvoiceSummaryFromInvoice(invoice);
@@ -422,7 +542,8 @@ class _PosPageState extends State<PosPage> {
 
     // Direct print removed (migrated to new Node backend architecture).
 
-    showDialog(
+  if (kPosVerbose) debugPrint('[POS] showing invoice dialog');
+  showDialog(
         context: context,
         barrierDismissible: true,
         builder: (dialogCtx) => AlertDialog(
@@ -441,18 +562,65 @@ class _PosPageState extends State<PosPage> {
                   onPressed: _isPrinting ? null : () async {
                     setState(() => _isPrinting = true);
                     try {
-                      final pdfBytes = await _buildThermalPdf(invoice, widthMm: 48, marginMm: 4, density: 8);
-                      final req = http.MultipartRequest('POST', Uri.parse('$_backendBase/print-pdf'))
-                        ..files.add(http.MultipartFile.fromBytes('file', pdfBytes, filename: 'invoice_${invoice.invoiceNumber}.pdf'));
-                      final streamed = await req.send();
-                      final resp = await http.Response.fromStream(streamed);
-                      if (resp.statusCode == 200) {
-                        _snack('Invoice printed');
+                      bool directOk = false;
+                      if (kEnableDirectPsPrint) {
+                        try { directOk = await directWindowsPrintInvoice(invoice); } catch (_) { directOk = false; }
+                      }
+                      if (directOk) {
+                        _snack('Invoice printed (direct)');
+                        if (kPosVerbose) debugPrint('[POS] direct print success');
                       } else {
-                        _snack('Print failed: ${resp.statusCode}');
+                        if (kIsWeb) {
+                          // Web: try backend, then always fall back to browser print
+                          bool backendOk = false;
+                          if (_canUseBackend) {
+                            if (kPosVerbose) debugPrint('[POS] print-invoice POST');
+                            try {
+                              final resp = await http.post(Uri.parse('$_backendBase/print-invoice'),
+                                  headers: {'Content-Type': 'application/json'},
+                                  body: jsonEncode({'invoice': invoice.toJson()}));
+                              if (resp.statusCode == 200) {
+                                backendOk = true;
+                                _snack('Invoice printed');
+                                if (kPosVerbose) debugPrint('[POS] backend print success');
+                                return;
+                              } else if (kPosVerbose) {
+                                debugPrint('[POS] backend print failed: ${resp.statusCode} ${resp.body}');
+                              }
+                            } catch (e) {
+                              if (kPosVerbose) debugPrint('[POS][web] backend print error: $e');
+                            }
+                          }
+                          if (!backendOk) {
+                            if (kWebStrictSilent) {
+                              _snack('Silent print unavailable (backend offline)');
+                            } else {
+                              final handle = webPrintPreopen();
+                              final handled = await webPrintPopulateAndPrint(handle, invoice);
+                              if (handled) {
+                                _snack('Browser print opened');
+                                return;
+                              }
+                              _snack('Print error (popup blocked?)');
+                            }
+                          }
+                        } else {
+                          if (kPosVerbose) debugPrint('[POS] print-invoice POST');
+                          final resp = await http.post(Uri.parse('$_backendBase/print-invoice'),
+                              headers: {'Content-Type': 'application/json'},
+                              body: jsonEncode({'invoice': invoice.toJson()}));
+                          if (resp.statusCode == 200) {
+                            _snack('Invoice printed');
+                            if (kPosVerbose) debugPrint('[POS] backend print success');
+                          } else {
+                            _snack('Print failed: ${resp.statusCode} ${resp.body}');
+                            if (kPosVerbose) debugPrint('[POS] backend print failed: ${resp.statusCode} ${resp.body}');
+                          }
+                        }
                       }
                     } catch (e) {
-                      _snack('Print error: $e');
+                      _snack('Print error');
+                      if (kPosVerbose) debugPrint('[POS] print error: $e');
                     } finally {
                       if (mounted) setState(() => _isPrinting = false);
                     }
@@ -461,7 +629,12 @@ class _PosPageState extends State<PosPage> {
                   label: const Text('Print'),
                 ),
                 TextButton(
-                  onPressed: () => Navigator.of(dialogCtx, rootNavigator: true).pop(),
+                  onPressed: () {
+                    // Use local navigator to avoid popping the shell root route.
+                    if (Navigator.of(dialogCtx).canPop()) {
+                      Navigator.of(dialogCtx).pop();
+                    }
+                  },
                   child: const Text('Close'),
                 ),
               ],
@@ -489,77 +662,141 @@ class _PosPageState extends State<PosPage> {
   double get subtotal => cart.values.fold(0.0, (s,it)=> s + it.product.price * it.qty);
 
   Future<void> _applyLoyaltyRewardsForCustomer(InvoiceData invoice) async {
-    final customerId = selectedCustomer?.id;
-    if (customerId == null || customerId.isEmpty) return; // walk-in
-    final fs = FirebaseFirestore.instance;
-    final settingsRef = fs.collection('settings').doc('loyalty_config');
-    final customerRef = fs.collection('customers').doc(customerId);
-    double earned = 0;
-    double newPointsTotal = 0;
-    await fs.runTransaction((tx) async {
-      final settingsSnap = await tx.get(settingsRef);
-      final settingsData = settingsSnap.data() ?? {};
-      double pointsPerCurrency = 0.01; // 1 point per 100 currency
-      final ppcRaw = settingsData['pointsPerCurrency'];
-      if (ppcRaw is num) {
-        pointsPerCurrency = ppcRaw.toDouble();
-      } else if (ppcRaw is String) {
-        pointsPerCurrency = double.tryParse(ppcRaw) ?? pointsPerCurrency;
+    try {
+      final customerId = selectedCustomer?.id;
+      if (customerId == null || customerId.isEmpty) {
+        if (kPosVerbose) debugPrint('[LOYALTY] abort: no customer');
+        return; // walk-in
       }
-      List<Map<String, dynamic>> rawTiers = [];
-      final tiersData = settingsData['tiers'];
-      if (tiersData is List) {
-        for (final t in tiersData) {
-          if (t is Map) rawTiers.add(Map<String, dynamic>.from(t));
+      final fs = FirebaseFirestore.instance;
+      final settingsRef = fs.collection('settings').doc('loyalty_config');
+      final customerRef = fs.collection('customers').doc(customerId);
+      double earned = 0;
+      double newPointsTotal = 0;
+      if (kPosVerbose) debugPrint('[LOYALTY] start invoice=${invoice.invoiceNumber} grand=${invoice.grandTotal} cust=$customerId');
+      if (kPosVerbose) {
+        try {
+          final u = FirebaseAuth.instance.currentUser;
+          debugPrint('[LOYALTY][auth] user=' + (u==null ? 'null' : '${u.uid} email=${u.email}'));
+        } catch (e) {
+          debugPrint('[LOYALTY][auth] error $e');
         }
       }
-      rawTiers.sort((a, b) {
-        final am = (a['minSpend'] is num) ? (a['minSpend'] as num).toDouble() : double.tryParse('${a['minSpend']}') ?? 0;
-        final bm = (b['minSpend'] is num) ? (b['minSpend'] as num).toDouble() : double.tryParse('${b['minSpend']}') ?? 0;
-        return am.compareTo(bm);
-      });
-      final custSnap = await tx.get(customerRef);
-      final custData = custSnap.data() ?? {};
-      final prevPointsRaw = custData['loyaltyPoints'];
-      double prevPoints = 0;
-      if (prevPointsRaw is num) prevPoints = prevPointsRaw.toDouble();
-      final prevSpendRaw = custData['totalSpend'];
-      double prevSpend = 0;
-      if (prevSpendRaw is num) prevSpend = prevSpendRaw.toDouble();
-      earned = (invoice.grandTotal * pointsPerCurrency);
-      final redeemedPts = invoice.redeemedPoints;
-      final afterRedeem = (prevPoints - redeemedPts).clamp(0, double.infinity);
-      newPointsTotal = afterRedeem + earned;
-      final newSpendTotal = prevSpend + invoice.grandTotal;
-      String? newStatus;
-      double? newDiscount;
-      for (final tier in rawTiers) {
-        final minSpend = (tier['minSpend'] is num) ? (tier['minSpend'] as num).toDouble() : double.tryParse('${tier['minSpend']}') ?? 0;
-        if (newSpendTotal >= minSpend) {
-          newStatus = (tier['name'] ?? '').toString().toLowerCase();
-          final discRaw = tier['discount'];
-          if (discRaw is num) newDiscount = discRaw.toDouble();
+      bool txSucceeded = false;
+      dynamic lastError;
+      try {
+        await fs.runTransaction((tx) async {
+          final settingsSnap = await tx.get(settingsRef);
+          final settingsData = settingsSnap.data() ?? {};
+          double pointsPerCurrency = 0.01;
+          final ppcRaw = settingsData['pointsPerCurrency'];
+          if (ppcRaw is num) pointsPerCurrency = ppcRaw.toDouble(); else if (ppcRaw is String) pointsPerCurrency = double.tryParse(ppcRaw) ?? pointsPerCurrency;
+          final rawTiers = <Map<String, dynamic>>[];
+          final tiersData = settingsData['tiers'];
+          if (tiersData is List) {
+            for (final t in tiersData) { if (t is Map) rawTiers.add(Map<String,dynamic>.from(t)); }
+          }
+            rawTiers.sort((a,b){
+              double am = (a['minSpend'] is num)? (a['minSpend'] as num).toDouble() : double.tryParse('${a['minSpend']}') ?? 0;
+              double bm = (b['minSpend'] is num)? (b['minSpend'] as num).toDouble() : double.tryParse('${b['minSpend']}') ?? 0;
+              return am.compareTo(bm);
+            });
+          final custSnap = await tx.get(customerRef);
+          final cdata = custSnap.data() ?? {};
+          double prevPoints = (cdata['loyaltyPoints'] is num) ? (cdata['loyaltyPoints'] as num).toDouble() : 0;
+          double prevSpend = (cdata['totalSpend'] is num) ? (cdata['totalSpend'] as num).toDouble() : 0;
+          final earnBase = invoice.grandTotal;
+          earned = double.parse((earnBase * pointsPerCurrency).toStringAsFixed(2));
+          if (earned < 0) earned = 0;
+          final redeemedPts = invoice.redeemedPoints;
+          final afterRedeem = (prevPoints - redeemedPts).clamp(0, double.infinity);
+          newPointsTotal = afterRedeem + earned;
+          final newSpendTotal = prevSpend + invoice.grandTotal;
+          String? newStatus; double? newDiscount;
+          for (final tier in rawTiers) {
+            final minSpend = (tier['minSpend'] is num)? (tier['minSpend'] as num).toDouble() : double.tryParse('${tier['minSpend']}') ?? 0;
+            if (newSpendTotal >= minSpend) {
+              newStatus = (tier['name'] ?? '').toString().toLowerCase();
+              final discRaw = tier['discount'];
+              if (discRaw is num) newDiscount = discRaw.toDouble();
+            }
+          }
+          if (kPosVerbose) debugPrint('[LOYALTY][tx] prevPoints=$prevPoints earned=$earned redeemed=$redeemedPts newPoints=$newPointsTotal');
+          final update = <String,dynamic>{
+            'loyaltyPoints': newPointsTotal,
+            'loyaltyUpdatedAt': FieldValue.serverTimestamp(),
+            'lastInvoiceNumber': invoice.invoiceNumber,
+            'lastInvoiceTotal': invoice.grandTotal,
+            'loyaltyEarnedLast': earned,
+            'loyaltyRedeemedLast': redeemedPts,
+            'totalSpend': newSpendTotal,
+          };
+          if (newStatus != null && newStatus.isNotEmpty) {
+            update['status'] = newStatus;
+            if (newDiscount != null) update['loyaltyDiscount'] = newDiscount;
+          }
+          tx.update(customerRef, update);
+        });
+        txSucceeded = true;
+      } catch (e, st) {
+        lastError = e;
+        if (kPosVerbose) debugPrint('[LOYALTY][tx-fail] $e\n$st');
+      }
+      if (!txSucceeded) {
+        // Attempt fallback non-transactional optimistic update if the error wasn't permission-denied
+  if (lastError is FirebaseException && lastError.code == 'permission-denied') {
+          if (mounted) _snack('Loyalty skipped (no permission)');
+          return;
+        }
+        try {
+          if (kPosVerbose) debugPrint('[LOYALTY][fallback] attempting direct update');
+          final custSnap = await customerRef.get();
+          final cdata = custSnap.data() ?? {};
+          double prevPoints = (cdata['loyaltyPoints'] is num) ? (cdata['loyaltyPoints'] as num).toDouble() : 0;
+          double prevSpend = (cdata['totalSpend'] is num) ? (cdata['totalSpend'] as num).toDouble() : 0;
+          double pointsPerCurrency = 0.01;
+          final settingsSnap = await settingsRef.get();
+          final settingsData = settingsSnap.data() ?? {};
+          final ppcRaw = settingsData['pointsPerCurrency'];
+          if (ppcRaw is num) pointsPerCurrency = ppcRaw.toDouble(); else if (ppcRaw is String) pointsPerCurrency = double.tryParse(ppcRaw) ?? pointsPerCurrency;
+          earned = double.parse((invoice.grandTotal * pointsPerCurrency).toStringAsFixed(2));
+          if (earned < 0) earned = 0;
+          final redeemedPts = invoice.redeemedPoints;
+          final afterRedeem = (prevPoints - redeemedPts).clamp(0, double.infinity);
+          newPointsTotal = afterRedeem + earned;
+          final newSpendTotal = prevSpend + invoice.grandTotal;
+          await customerRef.update({
+            'loyaltyPoints': newPointsTotal,
+            'loyaltyUpdatedAt': FieldValue.serverTimestamp(),
+            'lastInvoiceNumber': invoice.invoiceNumber,
+            'lastInvoiceTotal': invoice.grandTotal,
+            'loyaltyEarnedLast': earned,
+            'loyaltyRedeemedLast': invoice.redeemedPoints,
+            'totalSpend': newSpendTotal,
+          });
+          if (kPosVerbose) debugPrint('[LOYALTY][fallback] success new=$newPointsTotal earned=$earned');
+        } catch (fe, st2) {
+          if (kPosVerbose) debugPrint('[LOYALTY][fallback-fail] $fe\n$st2');
+          rethrow; // let outer catch handle final failure
         }
       }
-      final update = <String, dynamic>{
-        'loyaltyPoints': newPointsTotal,
-        'loyaltyUpdatedAt': FieldValue.serverTimestamp(),
-        'lastInvoiceNumber': invoice.invoiceNumber,
-        'lastInvoiceTotal': invoice.grandTotal,
-        'loyaltyEarnedLast': earned,
-        'loyaltyRedeemedLast': redeemedPts,
-        'totalSpend': newSpendTotal,
-      };
-      if (newStatus != null && newStatus.isNotEmpty) {
-        update['status'] = newStatus;
-        if (newDiscount != null) {
-          update['loyaltyDiscount'] = newDiscount;
+      if (!mounted) return;
+      if (kPosVerbose) debugPrint('[LOYALTY] success new=${newPointsTotal.toStringAsFixed(2)} earned=$earned');
+      _snack('Earned ${earned.toStringAsFixed(1)} pts (Total: ${newPointsTotal.toStringAsFixed(1)})');
+    } on FirebaseException catch (e) {
+      if (kPosVerbose) debugPrint('[LOYALTY][fail-inner] code=${e.code} msg=${e.message}');
+      if (mounted) {
+        if (e.code == 'permission-denied') {
+          _snack('Loyalty skipped (no permission)');
+        } else {
+          _snack('Loyalty error (${e.code})');
         }
       }
-      tx.update(customerRef, update);
-    });
-    if (!mounted) return;
-    _snack('Earned ${earned.toStringAsFixed(1)} pts (Total: ${newPointsTotal.toStringAsFixed(1)})');
+    } catch (e, st) {
+      if (kPosVerbose) debugPrint('[LOYALTY][uncaught] $e\n$st');
+      if (mounted) _snack('Loyalty update failed');
+      // swallow to avoid crashing outer sale flow
+    }
   }
 
   Future<void> _onCustomerSelected(Customer? c) async {
@@ -571,6 +808,8 @@ class _PosPageState extends State<PosPage> {
       return;
     }
     try {
+      // Ensure creditBalance field exists (idempotent)
+      await CustomerCreditService.ensureCreditField(chosen.id);
       final docRef = FirebaseFirestore.instance.collection('customers').doc(chosen.id);
       final snap = await docRef.get();
       if (snap.data() != null && mounted) {
@@ -806,10 +1045,12 @@ class _PosPageState extends State<PosPage> {
             },
             cart: cart,
             lineTaxes: lineTaxes,
-            onCheckout: completeSale,
+            onCheckout: () => completeSale(),
+            onCheckoutCreditMix: (amt) => completeSale(creditPaidInput: amt),
             selectedPaymentMode: selectedPaymentMode,
             onPaymentModeChanged: (m) => setState(() => selectedPaymentMode = m),
             onQuickPrint: _quickPrintFromPanel,
+            onPayCredit: (amt) => _payCustomerCredit(amt),
           ),
           
         ),
@@ -828,7 +1069,6 @@ class _PosPageState extends State<PosPage> {
           onScannerToggle: (v) => v ? _activateScanner() : _deactivateScanner(finalize: true),
           onBarcodeSubmitted: _scan,
           onSearchChanged: () => setState(() {}),
-          
         ),
         const SizedBox(height: 8),
         SizedBox(
@@ -906,10 +1146,12 @@ class _PosPageState extends State<PosPage> {
           },
           cart: cart,
           lineTaxes: lineTaxes,
-          onCheckout: completeSale,
+          onCheckout: () => completeSale(),
+          onCheckoutCreditMix: (amt) => completeSale(creditPaidInput: amt),
           selectedPaymentMode: selectedPaymentMode,
           onPaymentModeChanged: (m) => setState(() => selectedPaymentMode = m),
           onQuickPrint: _quickPrintFromPanel,
+          onPayCredit: (amt) => _payCustomerCredit(amt),
         ),
       ],
     );
@@ -1045,6 +1287,31 @@ class _PosPageState extends State<PosPage> {
       ),
     );
   }
+
+  Future<void> _payCustomerCredit(double enteredAmount) async {
+    final cust = selectedCustomer;
+    if (cust == null || cust.id.isEmpty) {
+      _snack('Select a customer');
+      return;
+    }
+    if (cart.isNotEmpty) {
+      _snack('Clear cart before credit repayment');
+      return;
+    }
+  final amount = enteredAmount.clamp(0, cust.creditBalance).toDouble();
+    if (amount <= 0) {
+      _snack('Enter amount');
+      return;
+    }
+    try {
+      await CustomerCreditService.repayCredit(customerId: cust.id, amount: amount);
+      _snack('Credit payment ₹${amount.toStringAsFixed(2)} recorded');
+      // Refresh customer doc to update live balance (stream listener will also update if active)
+      setState(() { selectedPaymentMode = PaymentMode.cash; });
+    } catch (e) {
+      _snack('Credit payment failed');
+    }
+  }
 }
 
 // _SearchableCustomerDropdown removed after introducing CheckoutPanel simple dropdown
@@ -1084,3 +1351,5 @@ class _HeldOrdersDialog extends StatelessWidget {
 
 // ---------------- Simple Print Settings Dialog (placeholder) ----------------
 // Print Settings UI removed; printing now sends to backend default printer.
+
+
diff --git a/lib/modules/pos/print_settings.dart b/lib/modules/pos/print_settings.dart
index 55b4666..8b8064b 100644
--- a/lib/modules/pos/print_settings.dart
+++ b/lib/modules/pos/print_settings.dart
@@ -1,5 +1,58 @@
-// Legacy print settings removed. Placeholder kept only to avoid stray references
-// while new backend-driven printing service is integrated.
-class PrintSettings {
-  static String get selectedPrinterLabel => 'N/A';
+import 'package:flutter/foundation.dart';
+
+/// Supported paper sizes (simplified for POS thermal + A4 scenarios).
+enum PaperSize { receipt, a4 }
+
+/// Orientation for larger page formats.
+enum PageOrientation { portrait, landscape }
+
+/// User-configurable print formatting options stored in-memory (could later persist via shared_preferences).
+class PrintSettings extends ChangeNotifier {
+  PaperSize paperSize;
+  PageOrientation orientation; // only relevant for A4 currently
+  bool scaleToFit; // whether to scale width to selected page width
+  int receiptCharWidth; // effective character width for receipt text formatting
+  int paperWidthMm; // physical thermal roll width (e.g. 58 / 80)
+  int fontSizePt; // monospace font size (points) for direct text printing
+
+  PrintSettings({
+    this.paperSize = PaperSize.receipt,
+    this.orientation = PageOrientation.portrait,
+    this.scaleToFit = false, // default off so explicit char width (24) is respected
+  this.receiptCharWidth = 20, // updated default to allow 20-char receipt width
+    this.paperWidthMm = 58,
+    this.fontSizePt = 9,
+  });
+
+  void update({
+    PaperSize? paperSize,
+    PageOrientation? orientation,
+    bool? scaleToFit,
+    int? receiptCharWidth,
+    int? paperWidthMm,
+    int? fontSizePt,
+  }) {
+    bool changed = false;
+    if (paperSize != null && paperSize != this.paperSize) { this.paperSize = paperSize; changed = true; }
+    if (orientation != null && orientation != this.orientation) { this.orientation = orientation; changed = true; }
+    if (scaleToFit != null && scaleToFit != this.scaleToFit) { this.scaleToFit = scaleToFit; changed = true; }
+    if (receiptCharWidth != null && receiptCharWidth != this.receiptCharWidth) { this.receiptCharWidth = receiptCharWidth; changed = true; }
+    if (paperWidthMm != null && paperWidthMm != this.paperWidthMm) { this.paperWidthMm = paperWidthMm; changed = true; }
+    if (fontSizePt != null && fontSizePt != this.fontSizePt) { this.fontSizePt = fontSizePt.clamp(6, 24); changed = true; }
+    if (changed) notifyListeners();
+  }
+
+  /// Derive char width from paper width when auto scaling.
+  int derivedCharWidth() {
+    if (paperSize != PaperSize.receipt) return receiptCharWidth;
+    final mm = paperWidthMm;
+    if (mm <= 50) return 32; // very narrow
+    if (mm <= 60) return 40; // 58mm
+    if (mm <= 72) return 48; // mid
+    if (mm <= 86) return 56; // 80mm
+    return 64; // super wide fallback
+  }
 }
+
+// Global (simple) singleton for now; could be provided via Riverpod or InheritedWidget later.
+final PrintSettings globalPrintSettings = PrintSettings();
diff --git a/lib/modules/pos/print_settings_dialog.dart b/lib/modules/pos/print_settings_dialog.dart
new file mode 100644
index 0000000..8380dc1
--- /dev/null
+++ b/lib/modules/pos/print_settings_dialog.dart
@@ -0,0 +1,167 @@
+import 'package:flutter/material.dart';
+import 'print_settings.dart';
+
+/// Session (in‑memory) preference: whether to show print settings automatically before web printing.
+/// Defaults to true so users see the configuration the first time.
+// Default changed to false so Print button acts immediately; user can still open settings via gear.
+bool globalShowWebPrintSettingsPref = false; // not persisted yet
+
+/// Opens the print settings dialog. If [showPrintButton] is true, a primary 'Print Now' button
+/// is shown and the Future<bool> resolves true only when user chooses to proceed with printing.
+/// When invoked with [showPrintButton], a "Don't show again" checkbox lets the user skip
+/// future auto display before printing (session only for now).
+Future<bool> showPrintSettingsDialog(BuildContext context, {bool showPrintButton = false}) async {
+  final ps = globalPrintSettings;
+  int tempWidth = ps.receiptCharWidth;
+  int tempPaperMm = ps.paperWidthMm;
+  int tempFontSize = ps.fontSizePt;
+  PaperSize tempSize = ps.paperSize;
+  PageOrientation tempOrientation = ps.orientation;
+  bool tempScale = ps.scaleToFit;
+  bool dontShowAgain = false;
+
+  final result = await showDialog<bool>(
+    context: context,
+    barrierDismissible: !showPrintButton, // force explicit choice when printing
+    builder: (ctx) {
+      return StatefulBuilder(builder: (ctx, setLocal) {
+        int previewWidth = tempScale && tempSize == PaperSize.receipt
+            ? _deriveCharWidth(tempPaperMm)
+            : tempWidth;
+        return AlertDialog(
+          title: Text(showPrintButton ? 'Print Settings & Preview' : 'Print Settings'),
+          content: SizedBox(
+            width: 420,
+            child: SingleChildScrollView(
+              child: Column(
+                mainAxisSize: MainAxisSize.min,
+                crossAxisAlignment: CrossAxisAlignment.start,
+                children: [
+                  Row(children:[
+                    const Text('Paper:'), const SizedBox(width:8),
+                    DropdownButton<PaperSize>(
+                      value: tempSize,
+                      items: const [
+                        DropdownMenuItem(value: PaperSize.receipt, child: Text('Receipt (Thermal)')),
+                        DropdownMenuItem(value: PaperSize.a4, child: Text('A4')),
+                      ],
+                      onChanged: (v){ if(v!=null) setLocal(()=> tempSize = v);},
+                    ),
+                  ]),
+                  const SizedBox(height: 8),
+                  Row(children:[
+                    const Text('Orientation:'), const SizedBox(width:8),
+                    DropdownButton<PageOrientation>(
+                      value: tempOrientation,
+                      items: const [
+                        DropdownMenuItem(value: PageOrientation.portrait, child: Text('Portrait')),
+                        DropdownMenuItem(value: PageOrientation.landscape, child: Text('Landscape')),
+                      ],
+                      onChanged: tempSize == PaperSize.receipt ? null : (v){ if(v!=null) setLocal(()=> tempOrientation = v);},
+                    ),
+                  ]),
+                  if (tempSize == PaperSize.receipt) const SizedBox(height: 8),
+                  if (tempSize == PaperSize.receipt) Row(children:[
+                    const Text('Width (mm):'), const SizedBox(width:8),
+                    DropdownButton<int>(
+                      value: tempPaperMm,
+                      items: const [
+                        DropdownMenuItem(value: 48, child: Text('48 mm')),
+                        DropdownMenuItem(value: 58, child: Text('58 mm')),
+                        DropdownMenuItem(value: 80, child: Text('80 mm')),
+                      ],
+                      onChanged: (v){ if(v!=null) setLocal(()=> tempPaperMm = v); },
+                    ),
+                  ]),
+                  const SizedBox(height: 8),
+                  SwitchListTile(
+                    contentPadding: EdgeInsets.zero,
+                    title: const Text('Auto scale to paper width'),
+                    value: tempScale,
+                    onChanged: (v)=> setLocal(()=> tempScale = v),
+                  ),
+                  const SizedBox(height: 8),
+                  Row(children:[
+                    const Text('Font size:'), const SizedBox(width:8),
+                    Expanded(
+                      child: Slider(
+                        min: 6,
+                        max: 24,
+                        divisions: 18,
+                        value: tempFontSize.toDouble(),
+                        label: '${tempFontSize}pt',
+                        onChanged: (v)=> setLocal(()=> tempFontSize = v.round()),
+                      ),
+                    ),
+                    SizedBox(
+                      width: 40,
+                      child: Text('${tempFontSize}pt', textAlign: TextAlign.right, style: const TextStyle(fontSize: 12)),
+                    )
+                  ]),
+                  const SizedBox(height: 8),
+                  if (tempSize == PaperSize.receipt && !tempScale) Column(
+                    crossAxisAlignment: CrossAxisAlignment.start,
+                    children:[
+                      const Text('Receipt Character Width'),
+                      Slider(
+                        min: 20,
+                        max: 80,
+                        divisions: 60,
+                        value: tempWidth.toDouble(),
+                        label: '$tempWidth',
+                        onChanged: (v)=> setLocal(()=> tempWidth = v.round()),
+                      ),
+                    ],
+                  ),
+                  const SizedBox(height: 4),
+                  Text('Preview width: $previewWidth chars • Font ${tempFontSize}pt (${tempSize == PaperSize.receipt ? '${tempPaperMm}mm' : 'A4'})',
+                    style: const TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),
+                  if (showPrintButton) ...[
+                    const Divider(height: 24),
+                    CheckboxListTile(
+                      contentPadding: EdgeInsets.zero,
+                      title: const Text("Don't show before printing again"),
+                      value: dontShowAgain,
+                      onChanged: (v)=> setLocal(()=> dontShowAgain = v ?? false),
+                    ),
+                  ],
+                ],
+              ),
+            ),
+          ),
+          actions: [
+            TextButton(onPressed: ()=> Navigator.pop(ctx, false), child: Text(showPrintButton ? 'Cancel' : 'Close')),
+            TextButton(
+              onPressed: () {
+                // Save settings only when explicitly applying changes.
+                ps.update(
+                  paperSize: tempSize,
+                  orientation: tempOrientation,
+                  scaleToFit: tempScale,
+                  receiptCharWidth: tempWidth,
+                  paperWidthMm: tempPaperMm,
+                  fontSizePt: tempFontSize,
+                );
+                if (showPrintButton && dontShowAgain) {
+                  globalShowWebPrintSettingsPref = false;
+                }
+                Navigator.pop(ctx, showPrintButton); // true if printing, false otherwise
+              },
+              child: Text(showPrintButton ? 'Print Now' : 'Save'),
+            )
+          ],
+        );
+      });
+    }
+  );
+
+  return result == true && showPrintButton; // proceed only when Print Now pressed
+}
+
+int _deriveCharWidth(int mm) {
+  if (mm <= 50) return 32;
+  if (mm <= 60) return 40;
+  if (mm <= 72) return 48;
+  if (mm <= 86) return 56;
+  return 64;
+}
diff --git a/lib/modules/pos/web_print_fallback.dart b/lib/modules/pos/web_print_fallback.dart
new file mode 100644
index 0000000..60df878
--- /dev/null
+++ b/lib/modules/pos/web_print_fallback.dart
@@ -0,0 +1,168 @@
+// Web-specific fallback printing (Flutter Web only).
+// Opens a new window/tab with simple HTML and triggers the browser print dialog.
+// ignore_for_file: avoid_web_libraries_in_flutter, deprecated_member_use
+import 'dart:async';
+import 'dart:html' as html;
+import 'invoice_models.dart';
+import 'package:flutter/foundation.dart';
+
+/// Opens a new tab/window and injects printable HTML, then triggers browser print.
+/// Returns false if popup blocked or any exception occurs.
+Future<bool> webFallbackPrintInvoice(InvoiceData invoice) async {
+  try {
+    final htmlContent = _buildHtml(invoice);
+    // Open immediately (synchronous with user gesture) to avoid popup blocker.
+    final opened = html.window.open('', '_blank');
+    final win = opened is html.Window ? opened : html.window; // ensure correct type
+    try {
+      final doc = (opened is html.Window) ? opened.document : html.document;
+      doc.documentElement?.innerHtml = htmlContent;
+    } catch (e) {
+      if (kDebugMode) debugPrint('[WEB PRINT] Failed injecting HTML: $e');
+      return false;
+    }
+    Future.delayed(const Duration(milliseconds: 60), () {
+      try { win.print(); } catch (e) { if (kDebugMode) debugPrint('[WEB PRINT] print() failed: $e'); }
+    });
+    return true;
+  } catch (e) {
+    if (kDebugMode) debugPrint('[WEB PRINT] Unexpected error: $e');
+    return false;
+  }
+}
+
+// Pre-open a print window synchronously (to avoid popup blockers) and return a handle.
+class PrintWindowHandle {
+  final html.Window win;
+  final html.Document doc;
+  PrintWindowHandle(this.win, this.doc);
+}
+
+PrintWindowHandle? webPrintPreopen() {
+  try {
+    final opened = html.window.open('', '_blank');
+    if (opened is html.Window) {
+      return PrintWindowHandle(opened, opened.document);
+    }
+  } catch (e) {
+    if (kDebugMode) debugPrint('[WEB PRINT] preopen failed: $e');
+  }
+  return null;
+}
+
+Future<bool> webPrintPopulateAndPrint(PrintWindowHandle? handle, InvoiceData invoice) async {
+  if (handle == null) return webFallbackPrintInvoice(invoice);
+  try {
+    final htmlContent = _buildHtml(invoice);
+    handle.doc.documentElement?.innerHtml = htmlContent;
+    Future.delayed(const Duration(milliseconds: 30), () {
+      try { handle.win.print(); } catch (e) { if (kDebugMode) debugPrint('[WEB PRINT] print() failed: $e'); }
+    });
+    return true;
+  } catch (e) {
+    if (kDebugMode) debugPrint('[WEB PRINT] populate/print failed: $e');
+    return false;
+  }
+}
+
+void webPrintClose(PrintWindowHandle? handle) {
+  try { handle?.win.close(); } catch (_) {}
+}
+
+String _buildHtml(InvoiceData inv) {
+  // We will produce a narrow receipt layout suitable for 58mm / 80mm thermal printers.
+  // Approach: generate a pre-formatted block with fixed character widths to avoid table overflow clipping.
+  // Fallback to basic ASCII alignment so no font-size scaling truncates columns.
+  const maxChars = 32; // typical 58mm @ 12cpi ~ 32 chars; adjust if using 80mm (48 chars) later.
+  String money(num v) => v.toStringAsFixed(2);
+  final lines = <String>[];
+
+  String center(String text) {
+    if (text.length >= maxChars) return text; // no pad if longer (will wrap later)
+    final pad = (maxChars - text.length) ~/ 2;
+    return ' ' * pad + text;
+  }
+
+  String padRight(String text, int width) {
+    if (text.length > width) return text.substring(0, width);
+    return text + ' ' * (width - text.length);
+  }
+  String wrapItemName(String name) {
+    final chunks = <String>[];
+    var remaining = name.trim();
+    while (remaining.isNotEmpty) {
+      if (remaining.length <= 16) { // 16 char for item column baseline
+        chunks.add(remaining);
+        break;
+      }
+      chunks.add(remaining.substring(0, 16));
+      remaining = remaining.substring(16);
+    }
+    return chunks.join('\n');
+  }
+
+  lines.add(center('Invoice')); // Title line
+  lines.add(center(inv.invoiceNumber));
+  lines.add('');
+  lines.add('Date: ${inv.timestamp.toLocal().toString().split('.').first}');
+  lines.add('Customer: ${inv.customerName}');
+  if (inv.customerPhone != null && inv.customerPhone!.isNotEmpty) {
+    lines.add('Phone: ${inv.customerPhone}');
+  }
+  if (inv.customerEmail != null && inv.customerEmail!.isNotEmpty) {
+    lines.add('Email: ${inv.customerEmail}');
+  }
+  lines.add('');
+
+  // Column headers (Item takes up to 16, Qty 3, Price 6, Total 7 = 32)
+  lines.add('Item             Qty Price  Total');
+  lines.add('-' * maxChars);
+
+  for (final l in inv.lines) {
+    final nameWrapped = wrapItemName(l.name);
+    final nameLines = nameWrapped.split('\n');
+    for (var i = 0; i < nameLines.length; i++) {
+      final segment = nameLines[i];
+      if (i == 0) {
+        final itemCol = padRight(segment, 16);
+        final qtyCol = padRight(l.qty.toString(), 3);
+        final priceCol = padRight(money(l.unitPrice), 6);
+        final totalCol = padRight(money(l.lineTotal), 7);
+        lines.add('$itemCol$qtyCol$priceCol$totalCol');
+      } else {
+        // continuation line for long name
+        lines.add(segment);
+      }
+    }
+  }
+  lines.add('-' * maxChars);
+  lines.add(padRight('Subtotal', 23) + padRight(money(inv.subtotal), 9));
+  lines.add(padRight('Discount', 23) + padRight('-${money(inv.discountTotal)}', 9));
+  lines.add(padRight('Tax', 23) + padRight(money(inv.taxTotal), 9));
+  if (inv.redeemedValue > 0) {
+    lines.add(padRight('Redeemed', 23) + padRight('-${money(inv.redeemedValue)}', 9));
+  }
+  lines.add(padRight('Grand Total', 23) + padRight(money(inv.grandTotal), 9));
+  lines.add(padRight('Payment Mode', 23) + padRight(inv.paymentMode, 9));
+  lines.add('');
+  lines.add('Thank you for your purchase.');
+
+  final plain = lines.map(_esc).join('\n');
+
+  final htmlBuf = StringBuffer();
+  htmlBuf.writeln('<!DOCTYPE html><html><head><meta charset="utf-8">');
+  htmlBuf.writeln('<meta name="viewport" content="width=device-width,initial-scale=1">');
+  htmlBuf.writeln('<title>Invoice ${_esc(inv.invoiceNumber)}</title>');
+  htmlBuf.writeln('<style>'
+      '@page{margin:2mm 2mm 4mm 2mm;}'
+      'body{margin:0;font-family:monospace;font-size:11px;line-height:1.25;}'
+      'pre{margin:0;white-space:pre-wrap;word-wrap:break-word;}'
+      '@media print { body{width:100%;} }'
+      '</style></head><body>');
+  htmlBuf.writeln('<pre>$plain</pre>');
+  htmlBuf.writeln('<script>window.addEventListener("load",()=>{setTimeout(()=>{try{window.print();}catch(e){}},30);});</script>');
+  htmlBuf.writeln('</body></html>');
+  return htmlBuf.toString();
+}
+
+String _esc(String v) => v.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');
diff --git a/lib/modules/pos/web_print_fallback_stub.dart b/lib/modules/pos/web_print_fallback_stub.dart
new file mode 100644
index 0000000..8d0625e
--- /dev/null
+++ b/lib/modules/pos/web_print_fallback_stub.dart
@@ -0,0 +1,12 @@
+// Fallback stub for non-web platforms: returns false meaning not handled.
+import 'invoice_models.dart';
+
+Future<bool> webFallbackPrintInvoice(InvoiceData invoice) async {
+  return false; // Not supported off-web.
+}
+
+// Stub types and functions for non-web platforms
+class PrintWindowHandle {}
+PrintWindowHandle? webPrintPreopen() => null;
+Future<bool> webPrintPopulateAndPrint(PrintWindowHandle? handle, InvoiceData invoice) async => false;
+void webPrintClose(PrintWindowHandle? handle) {}
diff --git a/lib/modules/pos/windows_print.dart b/lib/modules/pos/windows_print.dart
new file mode 100644
index 0000000..3ba4ce2
--- /dev/null
+++ b/lib/modules/pos/windows_print.dart
@@ -0,0 +1,142 @@
+// Windows-specific direct printing using a hidden PowerShell process launched via VBScript.
+// This avoids popping a console window in front of the Flutter POS UI.
+//
+// Strategy:
+// 1. Build a plain-text receipt from the InvoiceData (thermal-friendly, 42 cols target).
+// 2. Base64 encode the receipt to simplify escaping & pass to a transient PowerShell script.
+// 3. Create a temporary .ps1 and a .vbs launcher (wscript hidden, window style 0).
+// 4. Launch via wscript.exe detached so it runs fully in background.
+// 5. Return true if we managed to spawn the process (fire-and-forget), false on failure.
+//
+// NOTE: This is a best-effort local fallback when the Node backend is unavailable / undesired.
+//       For richer formatting (logos, QR, ESC/POS commands) keep using the backend pipeline.
+
+import 'dart:io';
+import 'dart:convert';
+import 'invoice_models.dart';
+import 'print_settings.dart';
+
+/// Public entry used by POS UI (conditionally imported).
+Future<bool> directWindowsPrintInvoice(InvoiceData invoice, {String? printerName}) async {
+  if (!Platform.isWindows) return false;
+  try {
+    final settings = globalPrintSettings;
+    int width;
+    if (settings.paperSize == PaperSize.receipt) {
+      width = settings.scaleToFit ? settings.derivedCharWidth() : settings.receiptCharWidth;
+    } else {
+      width = 80; // A4 text fallback width
+    }
+  width = width.clamp(20, 120);
+    final text = _formatInvoicePlain(invoice, width: width);
+    final b64 = base64Encode(utf8.encode(text));
+
+    final tmpDir = Directory.systemTemp;
+    final ts = DateTime.now().millisecondsSinceEpoch;
+    final ps1 = File('${tmpDir.path}\\print_invoice_$ts.ps1');
+    final vbs = File('${tmpDir.path}\\launch_print_invoice_$ts.vbs');
+
+    final sanitizedPrinter = (printerName ?? '').replaceAll('"', '');
+
+  final script = _buildPowerShellScript(b64, sanitizedPrinter, settings.fontSizePt.clamp(6,24));
+    await ps1.writeAsString(script, flush: true);
+
+    final psPathEsc = ps1.path.replaceAll('"', '""');
+    final vbsContent = '''
+Set sh = CreateObject("WScript.Shell")
+cmd = "powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File ""$psPathEsc"""
+sh.Run cmd, 0, False
+''';
+    await vbs.writeAsString(vbsContent, flush: true);
+
+    await Process.start('wscript.exe', [vbs.path], mode: ProcessStartMode.detached);
+    return true;
+  } catch (_) {
+    return false;
+  }
+}
+
+String _buildPowerShellScript(String base64Body, String printerName, int fontSize) {
+  // Minimalistic PS1 that prints a simple text block using .NET PrintDocument API.
+  final printerAssign = printerName.isEmpty
+    ? ''
+    : 'try { ' r'$doc' '.PrinterSettings.PrinterName = "${_escapePs(printerName)}" } catch {}';
+  return """
+\$ErrorActionPreference = 'SilentlyContinue'
+Add-Type -AssemblyName System.Drawing
+\$b64 = '${_escapePs(base64Body)}'
+\$bytes = [Convert]::FromBase64String(\$b64)
+\$text = [System.Text.Encoding]::UTF8.GetString(\$bytes)
+if (-not \$text) { return }
+\$doc = New-Object System.Drawing.Printing.PrintDocument
+$printerAssign
+\$docOrigin = New-Object System.Drawing.PointF 0,0
+\$font = New-Object System.Drawing.Font 'Consolas',$fontSize
+\$brush = [System.Drawing.Brushes]::Black
+\$doc.add_PrintPage({ param(\$sender,\$e) \$e.Graphics.DrawString(\$text,\$font,\$brush,\$docOrigin); \$e.HasMorePages = \$false })
+\$doc.Print()
+""";
+}
+
+String _formatInvoicePlain(InvoiceData inv, {int width = 40}) {
+  // Thermal printers often ~42 chars width default. Width is adjustable from settings.
+  String line([String ch = '-']) => ''.padRight(width, ch);
+  String money(num v) => v.toStringAsFixed(2);
+  final b = StringBuffer();
+  void writeWrapped(String text) {
+    if (text.isEmpty) return;
+    int i = 0;
+    while (i < text.length) {
+      final end = (i + width) > text.length ? text.length : i + width;
+      b.writeln(text.substring(i, end));
+      i = end;
+    }
+  }
+  // Header & meta info with wrapping to prevent truncation on narrow receipts (e.g. 20 cols)
+  writeWrapped('*** INVOICE ${inv.invoiceNumber} ***');
+  final dt = inv.timestamp.toLocal();
+  final dateStr = '${dt.year.toString().padLeft(4,'0')}-${dt.month.toString().padLeft(2,'0')}-${dt.day.toString().padLeft(2,'0')}';
+  final timeStr = '${dt.hour.toString().padLeft(2,'0')}:${dt.minute.toString().padLeft(2,'0')}:${dt.second.toString().padLeft(2,'0')}';
+  writeWrapped('Date: $dateStr $timeStr');
+  writeWrapped('Customer: ${inv.customerName}');
+  if ((inv.customerPhone ?? '').isNotEmpty) writeWrapped('Phone: ${inv.customerPhone}');
+  if ((inv.customerEmail ?? '').isNotEmpty) writeWrapped('Email: ${inv.customerEmail}');
+  b.writeln(line());
+  final itemHeader = width >= 34 ? '${'Item'.padRight(width - 13)}Qty   Total' : 'Item  Qty  Total';
+  b.writeln(itemHeader);
+  b.writeln(line());
+  for (final ln in inv.lines) {
+    final availNameWidth = width - 13; // leave space for qty + total columns
+    final truncated = ln.name.length > availNameWidth ? ln.name.substring(0, availNameWidth) : ln.name;
+    final name = truncated.padRight(availNameWidth);
+    final qty = ln.qty.toString().padLeft(3);
+    final total = money(ln.lineTotal).padLeft(8);
+    if (width >= 28) {
+      b.writeln('$name $qty $total');
+    } else {
+      b.writeln(truncated);
+      b.writeln(' x${ln.qty}  ${money(ln.lineTotal)}');
+    }
+  }
+  b.writeln(line());
+  b.writeln(_kv('Subtotal', inv.subtotal, width: width));
+  b.writeln(_kv('Discount', -inv.discountTotal, width: width));
+  b.writeln(_kv('Tax', inv.taxTotal, width: width));
+  if (inv.redeemedValue > 0) b.writeln(_kv('Redeemed', -inv.redeemedValue, width: width));
+  b.writeln(line('='));
+  b.writeln(_kv('TOTAL', inv.grandTotal - inv.redeemedValue, bold: true, width: width));
+  b.writeln(line());
+  b.writeln('Paid via: ${inv.paymentMode}');
+  b.writeln('Thank you!');
+  return b.toString();
+}
+
+String _kv(String k, num v, {bool bold = false, int width = 40}) {
+  final label = bold ? k.toUpperCase() : k;
+  final value = (v >= 0 ? ' ' : '') + v.toStringAsFixed(2);
+  final space = width - label.length - value.length;
+  final pad = space > 0 ? ''.padRight(space) : ' ';
+  return '$label$pad$value';
+}
+
+String _escapePs(String input) => input.replaceAll("'", "''").replaceAll('`', '``');
diff --git a/lib/modules/pos/windows_print_stub.dart b/lib/modules/pos/windows_print_stub.dart
new file mode 100644
index 0000000..0ffbca1
--- /dev/null
+++ b/lib/modules/pos/windows_print_stub.dart
@@ -0,0 +1,9 @@
+// Stub for non-Windows or platforms where direct PowerShell printing is unavailable.
+// The real implementation lives in windows_print.dart (conditionally imported).
+import 'invoice_models.dart';
+
+/// Attempts to print an invoice directly via Windows PowerShell (hidden window).
+/// On non-Windows platforms or when unsupported returns false immediately.
+Future<bool> directWindowsPrintInvoice(InvoiceData invoice, {String? printerName}) async {
+  return false; // Not supported on this platform build.
+}
diff --git a/lib/modules/printing_demo/print_demo.dart b/lib/modules/printing_demo/print_demo.dart
index a822e95..fe8f8df 100644
--- a/lib/modules/printing_demo/print_demo.dart
+++ b/lib/modules/printing_demo/print_demo.dart
@@ -1,114 +1,21 @@
-import 'dart:convert';
-import 'dart:typed_data';
 import 'package:flutter/material.dart';
-import 'package:flutter/foundation.dart';
-import 'package:http/http.dart' as http;
-import 'package:pdf/widgets.dart' as pw;
-import 'package:pdf/pdf.dart';
 
-class PrintDemoPage extends StatefulWidget {
+/// Legacy printing demo removed. This placeholder kept only so existing routes don't break.
+/// All printing is now handled through the POS screen which sends a PDF to the backend
+/// and prints directly to the system default printer (configured outside the app).
+class PrintDemoPage extends StatelessWidget {
   const PrintDemoPage({super.key});
-  @override
-  State<PrintDemoPage> createState() => _PrintDemoPageState();
-}
-
-class _PrintDemoPageState extends State<PrintDemoPage> {
-  final TextEditingController _receiptText = TextEditingController(text: 'Demo Store\nItem A  2 x 10.00 = 20.00\nItem B  1 x 15.00 = 15.00\n---------------------------\nTOTAL: 35.00\nTHANK YOU!');
-  late final String backendBase;
-  bool printing = false;
-
-  @override
-  void initState() {
-    super.initState();
-    backendBase = _resolveBackendBase();
-  }
-
-  String _resolveBackendBase() {
-    const envUrl = String.fromEnvironment('PRINTER_BACKEND_URL', defaultValue: '');
-    if (envUrl.isNotEmpty) return envUrl;
-    if (kIsWeb) {
-      final scheme = Uri.base.scheme == 'https' ? 'https' : 'http';
-      final host = Uri.base.host.isEmpty ? 'localhost' : Uri.base.host;
-      const port = 5005;
-      return '$scheme://$host:$port';
-    }
-    return 'http://localhost:5005';
-  }
-
-  Future<void> _printText() async {
-    setState(()=> printing = true);
-    try {
-      // Send only the text. The backend should use its default/connected printer.
-      final resp = await http.post(
-        Uri.parse('$backendBase/print-text'),
-        headers: {'Content-Type':'application/json'},
-        body: jsonEncode({'text': _receiptText.text}),
-      );
-      if (resp.statusCode == 200) {
-        _snack('Printed');
-      } else {
-        _snack('Print failed: ${resp.statusCode}');
-      }
-    } catch (e) { _snack('Print error: $e'); } finally { setState(()=> printing = false); }
-  }
-
-  Future<void> _printPdf() async {
-    setState(()=> printing = true);
-    try {
-      final pdfBytes = await _buildDemoPdf();
-      final req = http.MultipartRequest('POST', Uri.parse('$backendBase/print-pdf'))
-        ..files.add(http.MultipartFile.fromBytes('file', pdfBytes, filename: 'receipt.pdf'));
-      final streamed = await req.send();
-      final resp = await http.Response.fromStream(streamed);
-      if (resp.statusCode == 200) {
-        _snack('PDF Printed');
-      } else { _snack('PDF print failed: ${resp.statusCode}'); }
-    } catch (e) { _snack('PDF print error: $e'); } finally { setState(()=> printing = false); }
-  }
-
-  Future<Uint8List> _buildDemoPdf() async {
-    final doc = pw.Document();
-    doc.addPage(pw.Page(
-      pageFormat: PdfPageFormat.roll80,
-      build: (ctx) {
-        return pw.Column(children: [
-          pw.Text('DEMO STORE', style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
-          pw.SizedBox(height: 4),
-          pw.Text(DateTime.now().toString().substring(0,19)),
-          pw.Divider(),
-          pw.Text('Item A    2 x 10.00 = 20.00'),
-            pw.Text('Item B    1 x 15.00 = 15.00'),
-          pw.Divider(),
-          pw.Text('TOTAL 35.00', style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold)),
-          pw.SizedBox(height: 6),
-          pw.BarcodeWidget(data: 'https://example.com', barcode: pw.Barcode.qrCode()),
-          pw.SizedBox(height: 8),
-          pw.Text('Thank you!'),
-        ]);
-      }
-    ));
-    return doc.save();
-  }
-
-  void _snack(String msg) => ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
 
   @override
   Widget build(BuildContext context) {
-    return Scaffold(
-      appBar: AppBar(title: const Text('Printing Demo')),
-      body: Padding(
-        padding: const EdgeInsets.all(16),
-        child: SingleChildScrollView(
-          child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
-            const SizedBox(height: 8),
-            TextField(controller: _receiptText, maxLines: 8, decoration: const InputDecoration(labelText: 'Receipt Text (for Print Text)', border: OutlineInputBorder())),
-            const SizedBox(height: 16),
-            Row(children:[
-              ElevatedButton.icon(onPressed: printing ? null : _printText, icon: const Icon(Icons.print), label: const Text('Print Text Receipt')),
-              const SizedBox(width: 12),
-              ElevatedButton.icon(onPressed: printing ? null : _printPdf, icon: const Icon(Icons.picture_as_pdf), label: const Text('Print PDF Receipt')),
-            ]),
-          ]),
+    return const Scaffold(
+      body: Center(
+        child: Padding(
+          padding: EdgeInsets.all(24),
+          child: Text(
+            'Printing demo removed. Use the POS screen for one-click invoice printing to the default printer.',
+            textAlign: TextAlign.center,
+          ),
         ),
       ),
     );
diff --git a/printer_backend/config.json b/printer_backend/config.json
index 294ab24..762a82f 100644
--- a/printer_backend/config.json
+++ b/printer_backend/config.json
@@ -1,4 +1,6 @@
 {
-  "defaultPrinter": null,
-  "settings": {}
-}
+  "defaultPrinter": "POS58(2)",
+  "settings": {
+    "monochrome": true
+  }
+}
\ No newline at end of file
diff --git a/printer_backend/package-lock.json b/printer_backend/package-lock.json
index 0d503f5..58dc191 100644
--- a/printer_backend/package-lock.json
+++ b/printer_backend/package-lock.json
@@ -12,7 +12,18 @@
         "body-parser": "^1.20.2",
         "cors": "^2.8.5",
         "express": "^4.19.2",
-        "pdf-to-printer": "^5.0.0"
+        "express-fileupload": "^1.5.2",
+        "pdf-to-printer": "^5.0.0",
+        "pdfkit": "^0.15.0"
+      }
+    },
+    "node_modules/@swc/helpers": {
+      "version": "0.3.17",
+      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.3.17.tgz",
+      "integrity": "sha512-tb7Iu+oZ+zWJZ3HJqwx8oNwSDIU440hmVMDPhpACWQWnrZHK99Bxs70gT1L2dnr5Hg50ZRWEFkQCAnOVVV0z1Q==",
+      "license": "MIT",
+      "dependencies": {
+        "tslib": "^2.4.0"
       }
     },
     "node_modules/accepts": {
@@ -28,12 +39,63 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/array-buffer-byte-length": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/array-buffer-byte-length/-/array-buffer-byte-length-1.0.2.tgz",
+      "integrity": "sha512-LHE+8BuR7RYGDKvnrmcuSq3tDcKv9OFEXQt/HpbZhY7V6h0zlUXutnAD82GiFx9rdieCMjkvtcsPqBwgUl1Iiw==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.3",
+        "is-array-buffer": "^3.0.5"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/array-flatten": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
       "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==",
       "license": "MIT"
     },
+    "node_modules/available-typed-arrays": {
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.7.tgz",
+      "integrity": "sha512-wvUjBtSGN7+7SjNpq/9M2Tg350UZD3q62IFZLbRAR1bSMlCo1ZaeW+BJ+D090e4hIIZLBcTDWe4Mh4jvUDajzQ==",
+      "license": "MIT",
+      "dependencies": {
+        "possible-typed-array-names": "^1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/base64-js": {
+      "version": "1.5.1",
+      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
+      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/feross"
+        },
+        {
+          "type": "patreon",
+          "url": "https://www.patreon.com/feross"
+        },
+        {
+          "type": "consulting",
+          "url": "https://feross.org/support"
+        }
+      ],
+      "license": "MIT"
+    },
     "node_modules/body-parser": {
       "version": "1.20.3",
       "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
@@ -58,6 +120,26 @@
         "npm": "1.2.8000 || >= 1.4.16"
       }
     },
+    "node_modules/brotli": {
+      "version": "1.3.3",
+      "resolved": "https://registry.npmjs.org/brotli/-/brotli-1.3.3.tgz",
+      "integrity": "sha512-oTKjJdShmDuGW94SyyaoQvAjf30dZaHnjJ8uAF+u2/vGJkJbJPJAT1gDiOJP5v1Zb6f9KEyW/1HpuaWIXtGHPg==",
+      "license": "MIT",
+      "dependencies": {
+        "base64-js": "^1.1.2"
+      }
+    },
+    "node_modules/busboy": {
+      "version": "1.6.0",
+      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
+      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
+      "dependencies": {
+        "streamsearch": "^1.1.0"
+      },
+      "engines": {
+        "node": ">=10.16.0"
+      }
+    },
     "node_modules/bytes": {
       "version": "3.1.2",
       "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
@@ -67,6 +149,24 @@
         "node": ">= 0.8"
       }
     },
+    "node_modules/call-bind": {
+      "version": "1.0.8",
+      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.8.tgz",
+      "integrity": "sha512-oKlSFMcMwpUg2ednkhQ454wfWiU/ul3CkJe/PEHcTKuiX6RpbehUiFMXu13HalGZxfUwCQzZG747YXBn1im9ww==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind-apply-helpers": "^1.0.0",
+        "es-define-property": "^1.0.0",
+        "get-intrinsic": "^1.2.4",
+        "set-function-length": "^1.2.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/call-bind-apply-helpers": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
@@ -96,6 +196,15 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/clone": {
+      "version": "2.1.2",
+      "resolved": "https://registry.npmjs.org/clone/-/clone-2.1.2.tgz",
+      "integrity": "sha512-3Pe/CF1Nn94hyhIYpjtiLhdCoEoz0DqQ+988E9gmeEdQZlojxnOb74wctFyuwWQHzqyf9X7C7MG8juUpqBJT8w==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.8"
+      }
+    },
     "node_modules/content-disposition": {
       "version": "0.5.4",
       "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
@@ -145,6 +254,12 @@
         "node": ">= 0.10"
       }
     },
+    "node_modules/crypto-js": {
+      "version": "4.2.0",
+      "resolved": "https://registry.npmjs.org/crypto-js/-/crypto-js-4.2.0.tgz",
+      "integrity": "sha512-KALDyEYgpY+Rlob/iriUtjV6d5Eq+Y191A5g4UqLAi8CyGP9N1+FdVbkc1SxKc2r4YAYqG8JzO2KGL+AizD70Q==",
+      "license": "MIT"
+    },
     "node_modules/debug": {
       "version": "2.6.9",
       "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
@@ -154,6 +269,72 @@
         "ms": "2.0.0"
       }
     },
+    "node_modules/deep-equal": {
+      "version": "2.2.3",
+      "resolved": "https://registry.npmjs.org/deep-equal/-/deep-equal-2.2.3.tgz",
+      "integrity": "sha512-ZIwpnevOurS8bpT4192sqAowWM76JDKSHYzMLty3BZGSswgq6pBaH3DhCSW5xVAZICZyKdOBPjwww5wfgT/6PA==",
+      "license": "MIT",
+      "dependencies": {
+        "array-buffer-byte-length": "^1.0.0",
+        "call-bind": "^1.0.5",
+        "es-get-iterator": "^1.1.3",
+        "get-intrinsic": "^1.2.2",
+        "is-arguments": "^1.1.1",
+        "is-array-buffer": "^3.0.2",
+        "is-date-object": "^1.0.5",
+        "is-regex": "^1.1.4",
+        "is-shared-array-buffer": "^1.0.2",
+        "isarray": "^2.0.5",
+        "object-is": "^1.1.5",
+        "object-keys": "^1.1.1",
+        "object.assign": "^4.1.4",
+        "regexp.prototype.flags": "^1.5.1",
+        "side-channel": "^1.0.4",
+        "which-boxed-primitive": "^1.0.2",
+        "which-collection": "^1.0.1",
+        "which-typed-array": "^1.1.13"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/define-data-property": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/define-data-property/-/define-data-property-1.1.4.tgz",
+      "integrity": "sha512-rBMvIzlpA8v6E+SJZoo++HAYqsLrkg7MSfIinMPFhmkorw7X+dOXVJQs+QT69zGkzMyfDnIMN2Wid1+NbL3T+A==",
+      "license": "MIT",
+      "dependencies": {
+        "es-define-property": "^1.0.0",
+        "es-errors": "^1.3.0",
+        "gopd": "^1.0.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/define-properties": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.2.1.tgz",
+      "integrity": "sha512-8QmQKqEASLd5nx0U1B1okLElbUuuttJ/AnYmRXbbbGDWh6uS208EjD4Xqq/I9wK7u0v6O08XhTWnt5XtEbR6Dg==",
+      "license": "MIT",
+      "dependencies": {
+        "define-data-property": "^1.0.1",
+        "has-property-descriptors": "^1.0.0",
+        "object-keys": "^1.1.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/depd": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
@@ -173,6 +354,12 @@
         "npm": "1.2.8000 || >= 1.4.16"
       }
     },
+    "node_modules/dfa": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/dfa/-/dfa-1.2.0.tgz",
+      "integrity": "sha512-ED3jP8saaweFTjeGX8HQPjeC1YYyZs98jGNZx6IiBvxW7JG5v492kamAQB3m2wop07CvU/RQmzcKr6bgcC5D/Q==",
+      "license": "MIT"
+    },
     "node_modules/dunder-proto": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
@@ -220,6 +407,26 @@
         "node": ">= 0.4"
       }
     },
+    "node_modules/es-get-iterator": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/es-get-iterator/-/es-get-iterator-1.1.3.tgz",
+      "integrity": "sha512-sPZmqHBe6JIiTfN5q2pEi//TwxmAFHwj/XEuYjTuse78i8KxaqMTTzxPoFKuzRpDpTJ+0NAbpfenkmH2rePtuw==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind": "^1.0.2",
+        "get-intrinsic": "^1.1.3",
+        "has-symbols": "^1.0.3",
+        "is-arguments": "^1.1.1",
+        "is-map": "^2.0.2",
+        "is-set": "^2.0.2",
+        "is-string": "^1.0.7",
+        "isarray": "^2.0.5",
+        "stop-iteration-iterator": "^1.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/es-object-atoms": {
       "version": "1.1.1",
       "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
@@ -293,6 +500,18 @@
         "url": "https://opencollective.com/express"
       }
     },
+    "node_modules/express-fileupload": {
+      "version": "1.5.2",
+      "resolved": "https://registry.npmjs.org/express-fileupload/-/express-fileupload-1.5.2.tgz",
+      "integrity": "sha512-wxUJn2vTHvj/kZCVmc5/bJO15C7aSMyHeuXYY3geKpeKibaAoQGcEv5+sM6nHS2T7VF+QHS4hTWPiY2mKofEdg==",
+      "license": "MIT",
+      "dependencies": {
+        "busboy": "^1.6.0"
+      },
+      "engines": {
+        "node": ">=12.0.0"
+      }
+    },
     "node_modules/finalhandler": {
       "version": "1.3.1",
       "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
@@ -311,6 +530,38 @@
         "node": ">= 0.8"
       }
     },
+    "node_modules/fontkit": {
+      "version": "1.9.0",
+      "resolved": "https://registry.npmjs.org/fontkit/-/fontkit-1.9.0.tgz",
+      "integrity": "sha512-HkW/8Lrk8jl18kzQHvAw9aTHe1cqsyx5sDnxncx652+CIfhawokEPkeM3BoIC+z/Xv7a0yMr0f3pRRwhGH455g==",
+      "license": "MIT",
+      "dependencies": {
+        "@swc/helpers": "^0.3.13",
+        "brotli": "^1.3.2",
+        "clone": "^2.1.2",
+        "deep-equal": "^2.0.5",
+        "dfa": "^1.2.0",
+        "restructure": "^2.0.1",
+        "tiny-inflate": "^1.0.3",
+        "unicode-properties": "^1.3.1",
+        "unicode-trie": "^2.0.0"
+      }
+    },
+    "node_modules/for-each": {
+      "version": "0.3.5",
+      "resolved": "https://registry.npmjs.org/for-each/-/for-each-0.3.5.tgz",
+      "integrity": "sha512-dKx12eRCVIzqCxFGplyFKJMPvLEWgmNtUrpTiJIR5u97zEhRG8ySrtboPHZXx7daLxQVrl643cTzbab2tkQjxg==",
+      "license": "MIT",
+      "dependencies": {
+        "is-callable": "^1.2.7"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/forwarded": {
       "version": "0.2.0",
       "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
@@ -338,6 +589,15 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/functions-have-names": {
+      "version": "1.2.3",
+      "resolved": "https://registry.npmjs.org/functions-have-names/-/functions-have-names-1.2.3.tgz",
+      "integrity": "sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==",
+      "license": "MIT",
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/get-intrinsic": {
       "version": "1.3.0",
       "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
@@ -387,6 +647,30 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/has-bigints": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/has-bigints/-/has-bigints-1.1.0.tgz",
+      "integrity": "sha512-R3pbpkcIqv2Pm3dUwgjclDRVmWpTJW2DcMzcIhEXEx1oh/CEMObMm3KLmRJOdvhM7o4uQBnwr8pzRK2sJWIqfg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/has-property-descriptors": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.2.tgz",
+      "integrity": "sha512-55JNKuIW+vq4Ke1BjOTjM2YctQIvCT7GFzHwmfZPGo5wnrgkid0YQtnAleFSqumZm4az3n2BS+erby5ipJdgrg==",
+      "license": "MIT",
+      "dependencies": {
+        "es-define-property": "^1.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/has-symbols": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
@@ -399,6 +683,21 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/has-tostringtag": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
+      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
+      "license": "MIT",
+      "dependencies": {
+        "has-symbols": "^1.0.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/hasown": {
       "version": "2.0.2",
       "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
@@ -445,6 +744,20 @@
       "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
       "license": "ISC"
     },
+    "node_modules/internal-slot": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/internal-slot/-/internal-slot-1.1.0.tgz",
+      "integrity": "sha512-4gd7VpWNQNB4UKKCFFVcp1AVv+FMOgs9NKzjHKusc8jTMhd5eL1NqQqOpE0KzMds804/yHlglp3uxgluOqAPLw==",
+      "license": "MIT",
+      "dependencies": {
+        "es-errors": "^1.3.0",
+        "hasown": "^2.0.2",
+        "side-channel": "^1.1.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/ipaddr.js": {
       "version": "1.9.1",
       "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
@@ -454,6 +767,263 @@
         "node": ">= 0.10"
       }
     },
+    "node_modules/is-arguments": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/is-arguments/-/is-arguments-1.2.0.tgz",
+      "integrity": "sha512-7bVbi0huj/wrIAOzb8U1aszg9kdi3KN/CyU19CTI7tAoZYEZoL9yCDXpbXN+uPsuWnP02cyug1gleqq+TU+YCA==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "has-tostringtag": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-array-buffer": {
+      "version": "3.0.5",
+      "resolved": "https://registry.npmjs.org/is-array-buffer/-/is-array-buffer-3.0.5.tgz",
+      "integrity": "sha512-DDfANUiiG2wC1qawP66qlTugJeL5HyzMpfr8lLK+jMQirGzNod0B12cFB/9q838Ru27sBwfw78/rdoU7RERz6A==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind": "^1.0.8",
+        "call-bound": "^1.0.3",
+        "get-intrinsic": "^1.2.6"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-bigint": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/is-bigint/-/is-bigint-1.1.0.tgz",
+      "integrity": "sha512-n4ZT37wG78iz03xPRKJrHTdZbe3IicyucEtdRsV5yglwc3GyUfbAfpSeD0FJ41NbUNSt5wbhqfp1fS+BgnvDFQ==",
+      "license": "MIT",
+      "dependencies": {
+        "has-bigints": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-boolean-object": {
+      "version": "1.2.2",
+      "resolved": "https://registry.npmjs.org/is-boolean-object/-/is-boolean-object-1.2.2.tgz",
+      "integrity": "sha512-wa56o2/ElJMYqjCjGkXri7it5FbebW5usLw/nPmCMs5DeZ7eziSYZhSmPRn0txqeW4LnAmQQU7FgqLpsEFKM4A==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.3",
+        "has-tostringtag": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-callable": {
+      "version": "1.2.7",
+      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz",
+      "integrity": "sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-date-object": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/is-date-object/-/is-date-object-1.1.0.tgz",
+      "integrity": "sha512-PwwhEakHVKTdRNVOw+/Gyh0+MzlCl4R6qKvkhuvLtPMggI1WAHt9sOwZxQLSGpUaDnrdyDsomoRgNnCfKNSXXg==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "has-tostringtag": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-map": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/is-map/-/is-map-2.0.3.tgz",
+      "integrity": "sha512-1Qed0/Hr2m+YqxnM09CjA2d/i6YZNfF6R2oRAOj36eUdS6qIV/huPJNSEpKbupewFs+ZsJlxsjjPbc0/afW6Lw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-number-object": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/is-number-object/-/is-number-object-1.1.1.tgz",
+      "integrity": "sha512-lZhclumE1G6VYD8VHe35wFaIif+CTy5SJIi5+3y4psDgWu4wPDoBhF8NxUOinEc7pHgiTsT6MaBb92rKhhD+Xw==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.3",
+        "has-tostringtag": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-regex": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/is-regex/-/is-regex-1.2.1.tgz",
+      "integrity": "sha512-MjYsKHO5O7mCsmRGxWcLWheFqN9DJ/2TmngvjKXihe6efViPqc274+Fx/4fYj/r03+ESvBdTXK0V6tA3rgez1g==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "gopd": "^1.2.0",
+        "has-tostringtag": "^1.0.2",
+        "hasown": "^2.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-set": {
+      "version": "2.0.3",
+      "resolved": "https://registry.npmjs.org/is-set/-/is-set-2.0.3.tgz",
+      "integrity": "sha512-iPAjerrse27/ygGLxw+EBR9agv9Y6uLeYVJMu+QNCoouJ1/1ri0mGrcWpfCqFZuzzx3WjtwxG098X+n4OuRkPg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-shared-array-buffer": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/is-shared-array-buffer/-/is-shared-array-buffer-1.0.4.tgz",
+      "integrity": "sha512-ISWac8drv4ZGfwKl5slpHG9OwPNty4jOWPRIhBpxOoD+hqITiwuipOQ2bNthAzwA3B4fIjO4Nln74N0S9byq8A==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-string": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/is-string/-/is-string-1.1.1.tgz",
+      "integrity": "sha512-BtEeSsoaQjlSPBemMQIrY1MY0uM6vnS1g5fmufYOtnxLGUZM2178PKbhsk7Ffv58IX+ZtcvoGwccYsh0PglkAA==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.3",
+        "has-tostringtag": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-symbol": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/is-symbol/-/is-symbol-1.1.1.tgz",
+      "integrity": "sha512-9gGx6GTtCQM73BgmHQXfDmLtfjjTUDSyoxTCbp5WtoixAhfgsDirWIcVQ/IHpvI5Vgd5i/J5F7B9cN/WlVbC/w==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "has-symbols": "^1.1.0",
+        "safe-regex-test": "^1.1.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-weakmap": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/is-weakmap/-/is-weakmap-2.0.2.tgz",
+      "integrity": "sha512-K5pXYOm9wqY1RgjpL3YTkF39tni1XajUIkawTLUo9EZEVUFga5gSQJF8nNS7ZwJQ02y+1YCNYcMh+HIf1ZqE+w==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/is-weakset": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmjs.org/is-weakset/-/is-weakset-2.0.4.tgz",
+      "integrity": "sha512-mfcwb6IzQyOKTs84CQMrOwW4gQcaTOAWJ0zzJCl2WSPDrWk/OzDaImWFH3djXhb24g4eudZfLRozAvPGw4d9hQ==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.3",
+        "get-intrinsic": "^1.2.6"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/isarray": {
+      "version": "2.0.5",
+      "resolved": "https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz",
+      "integrity": "sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==",
+      "license": "MIT"
+    },
+    "node_modules/jpeg-exif": {
+      "version": "1.1.4",
+      "resolved": "https://registry.npmjs.org/jpeg-exif/-/jpeg-exif-1.1.4.tgz",
+      "integrity": "sha512-a+bKEcCjtuW5WTdgeXFzswSrdqi0jk4XlEtZlx5A94wCoBpFjfFTbo/Tra5SpNCl/YFZPvcV1dJc+TAYeg6ROQ==",
+      "license": "MIT"
+    },
+    "node_modules/linebreak": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/linebreak/-/linebreak-1.1.0.tgz",
+      "integrity": "sha512-MHp03UImeVhB7XZtjd0E4n6+3xr5Dq/9xI/5FptGk5FrbDR3zagPa2DS6U8ks/3HjbKWG9Q1M2ufOzxV2qLYSQ==",
+      "license": "MIT",
+      "dependencies": {
+        "base64-js": "0.0.8",
+        "unicode-trie": "^2.0.0"
+      }
+    },
+    "node_modules/linebreak/node_modules/base64-js": {
+      "version": "0.0.8",
+      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-0.0.8.tgz",
+      "integrity": "sha512-3XSA2cR/h/73EzlXXdU6YNycmYI7+kicTxks4eJg2g39biHR84slg2+des+p7iHYhbRg/udIS4TD53WabcOUkw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/math-intrinsics": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
@@ -559,6 +1129,51 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/object-is": {
+      "version": "1.1.6",
+      "resolved": "https://registry.npmjs.org/object-is/-/object-is-1.1.6.tgz",
+      "integrity": "sha512-F8cZ+KfGlSGi09lJT7/Nd6KJZ9ygtvYC0/UYYLI9nmQKLMnydpB9yvbv9K1uSkEu7FU9vYPmVwLg328tX+ot3Q==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind": "^1.0.7",
+        "define-properties": "^1.2.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/object-keys": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
+      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/object.assign": {
+      "version": "4.1.7",
+      "resolved": "https://registry.npmjs.org/object.assign/-/object.assign-4.1.7.tgz",
+      "integrity": "sha512-nK28WOo+QIjBkDduTINE4JkF/UJJKyf2EJxvJKfblDpyg0Q+pkOHNTL0Qwy6NP6FhE/EnzV73BxxqcJaXY9anw==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind": "^1.0.8",
+        "call-bound": "^1.0.3",
+        "define-properties": "^1.2.1",
+        "es-object-atoms": "^1.0.0",
+        "has-symbols": "^1.1.0",
+        "object-keys": "^1.1.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/on-finished": {
       "version": "2.4.1",
       "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
@@ -571,6 +1186,12 @@
         "node": ">= 0.8"
       }
     },
+    "node_modules/pako": {
+      "version": "0.2.9",
+      "resolved": "https://registry.npmjs.org/pako/-/pako-0.2.9.tgz",
+      "integrity": "sha512-NUcwaKxUxWrZLpDG+z/xZaCgQITkA/Dv4V/T6bw7VON6l1Xz/VnrBqrYjZQ12TamKHzITTfOEIYUj48y2KXImA==",
+      "license": "MIT"
+    },
     "node_modules/parseurl": {
       "version": "1.3.3",
       "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
@@ -592,6 +1213,33 @@
       "integrity": "sha512-yPZoLWFjbjnHoYNVLU8fyoVA5wPMmT6U4+W/ip+sTDZdt5hwcVuQSVe96rrqRB0kEaKznNcLU7BXSo42R7AHVQ==",
       "license": "MIT"
     },
+    "node_modules/pdfkit": {
+      "version": "0.15.2",
+      "resolved": "https://registry.npmjs.org/pdfkit/-/pdfkit-0.15.2.tgz",
+      "integrity": "sha512-s3GjpdBFSCaeDSX/v73MI5UsPqH1kjKut2AXCgxQ5OH10lPVOu5q5vLAG0OCpz/EYqKsTSw1WHpENqMvp43RKg==",
+      "license": "MIT",
+      "dependencies": {
+        "crypto-js": "^4.2.0",
+        "fontkit": "^1.8.1",
+        "jpeg-exif": "^1.1.4",
+        "linebreak": "^1.0.2",
+        "png-js": "^1.0.0"
+      }
+    },
+    "node_modules/png-js": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/png-js/-/png-js-1.0.0.tgz",
+      "integrity": "sha512-k+YsbhpA9e+EFfKjTCH3VW6aoKlyNYI6NYdTfDL4CIvFnvsuO84ttonmZE7rc+v23SLTH8XX+5w/Ak9v0xGY4g=="
+    },
+    "node_modules/possible-typed-array-names": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/possible-typed-array-names/-/possible-typed-array-names-1.1.0.tgz",
+      "integrity": "sha512-/+5VFTchJDoVj3bhoqi6UeymcD00DAwb1nJwamzPvHEszJ4FpF6SNNbUbOS8yI56qHzdV8eK0qEfOSiodkTdxg==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/proxy-addr": {
       "version": "2.0.7",
       "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
@@ -644,6 +1292,32 @@
         "node": ">= 0.8"
       }
     },
+    "node_modules/regexp.prototype.flags": {
+      "version": "1.5.4",
+      "resolved": "https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.5.4.tgz",
+      "integrity": "sha512-dYqgNSZbDwkaJ2ceRd9ojCGjBq+mOm9LmtXnAnEGyHhN/5R7iDW2TRw3h+o/jCFxus3P2LfWIIiwowAjANm7IA==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bind": "^1.0.8",
+        "define-properties": "^1.2.1",
+        "es-errors": "^1.3.0",
+        "get-proto": "^1.0.1",
+        "gopd": "^1.2.0",
+        "set-function-name": "^2.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/restructure": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/restructure/-/restructure-2.0.1.tgz",
+      "integrity": "sha512-e0dOpjm5DseomnXx2M5lpdZ5zoHqF1+bqdMJUohoYVVQa7cBdnk7fdmeI6byNWP/kiME72EeTiSypTCVnpLiDg==",
+      "license": "MIT"
+    },
     "node_modules/safe-buffer": {
       "version": "5.2.1",
       "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
@@ -664,6 +1338,23 @@
       ],
       "license": "MIT"
     },
+    "node_modules/safe-regex-test": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/safe-regex-test/-/safe-regex-test-1.1.0.tgz",
+      "integrity": "sha512-x/+Cz4YrimQxQccJf5mKEbIa1NzeCRNI5Ecl/ekmlYaampdNLPalVyIcCZNNH3MvmqBugV5TMYZXv0ljslUlaw==",
+      "license": "MIT",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "es-errors": "^1.3.0",
+        "is-regex": "^1.2.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/safer-buffer": {
       "version": "2.1.2",
       "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
@@ -724,6 +1415,38 @@
         "node": ">= 0.8.0"
       }
     },
+    "node_modules/set-function-length": {
+      "version": "1.2.2",
+      "resolved": "https://registry.npmjs.org/set-function-length/-/set-function-length-1.2.2.tgz",
+      "integrity": "sha512-pgRc4hJ4/sNjWCSS9AmnS40x3bNMDTknHgL5UaMBTMyJnU90EgWh1Rz+MC9eFu4BuN/UwZjKQuY/1v3rM7HMfg==",
+      "license": "MIT",
+      "dependencies": {
+        "define-data-property": "^1.1.4",
+        "es-errors": "^1.3.0",
+        "function-bind": "^1.1.2",
+        "get-intrinsic": "^1.2.4",
+        "gopd": "^1.0.1",
+        "has-property-descriptors": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/set-function-name": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/set-function-name/-/set-function-name-2.0.2.tgz",
+      "integrity": "sha512-7PGFlmtwsEADb0WYyvCMa1t+yke6daIG4Wirafur5kcf+MhUnPms1UeR0CKQdTZD81yESwMHbtn+TR+dMviakQ==",
+      "license": "MIT",
+      "dependencies": {
+        "define-data-property": "^1.1.4",
+        "es-errors": "^1.3.0",
+        "functions-have-names": "^1.2.3",
+        "has-property-descriptors": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/setprototypeof": {
       "version": "1.2.0",
       "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
@@ -811,6 +1534,33 @@
         "node": ">= 0.8"
       }
     },
+    "node_modules/stop-iteration-iterator": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/stop-iteration-iterator/-/stop-iteration-iterator-1.1.0.tgz",
+      "integrity": "sha512-eLoXW/DHyl62zxY4SCaIgnRhuMr6ri4juEYARS8E6sCEqzKpOiE521Ucofdx+KnDZl5xmvGYaaKCk5FEOxJCoQ==",
+      "license": "MIT",
+      "dependencies": {
+        "es-errors": "^1.3.0",
+        "internal-slot": "^1.1.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/streamsearch": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
+      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
+      "engines": {
+        "node": ">=10.0.0"
+      }
+    },
+    "node_modules/tiny-inflate": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/tiny-inflate/-/tiny-inflate-1.0.3.tgz",
+      "integrity": "sha512-pkY1fj1cKHb2seWDy0B16HeWyczlJA9/WW3u3c4z/NiWDsO3DOU5D7nhTLE9CF0yXv/QZFY7sEJmj24dK+Rrqw==",
+      "license": "MIT"
+    },
     "node_modules/toidentifier": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
@@ -820,6 +1570,12 @@
         "node": ">=0.6"
       }
     },
+    "node_modules/tslib": {
+      "version": "2.8.1",
+      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
+      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
+      "license": "0BSD"
+    },
     "node_modules/type-is": {
       "version": "1.6.18",
       "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
@@ -833,6 +1589,26 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/unicode-properties": {
+      "version": "1.4.1",
+      "resolved": "https://registry.npmjs.org/unicode-properties/-/unicode-properties-1.4.1.tgz",
+      "integrity": "sha512-CLjCCLQ6UuMxWnbIylkisbRj31qxHPAurvena/0iwSVbQ2G1VY5/HjV0IRabOEbDHlzZlRdCrD4NhB0JtU40Pg==",
+      "license": "MIT",
+      "dependencies": {
+        "base64-js": "^1.3.0",
+        "unicode-trie": "^2.0.0"
+      }
+    },
+    "node_modules/unicode-trie": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/unicode-trie/-/unicode-trie-2.0.0.tgz",
+      "integrity": "sha512-x7bc76x0bm4prf1VLg79uhAzKw8DVboClSN5VxJuQ+LKDOVEW9CdH+VY7SP+vX7xCYQqzzgQpFqz15zeLvAtZQ==",
+      "license": "MIT",
+      "dependencies": {
+        "pako": "^0.2.5",
+        "tiny-inflate": "^1.0.0"
+      }
+    },
     "node_modules/unpipe": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
@@ -859,6 +1635,64 @@
       "engines": {
         "node": ">= 0.8"
       }
+    },
+    "node_modules/which-boxed-primitive": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/which-boxed-primitive/-/which-boxed-primitive-1.1.1.tgz",
+      "integrity": "sha512-TbX3mj8n0odCBFVlY8AxkqcHASw3L60jIuF8jFP78az3C2YhmGvqbHBpAjTRH2/xqYunrJ9g1jSyjCjpoWzIAA==",
+      "license": "MIT",
+      "dependencies": {
+        "is-bigint": "^1.1.0",
+        "is-boolean-object": "^1.2.1",
+        "is-number-object": "^1.1.1",
+        "is-string": "^1.1.1",
+        "is-symbol": "^1.1.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/which-collection": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/which-collection/-/which-collection-1.0.2.tgz",
+      "integrity": "sha512-K4jVyjnBdgvc86Y6BkaLZEN933SwYOuBFkdmBu9ZfkcAbdVbpITnDmjvZ/aQjRXQrv5EPkTnD1s39GiiqbngCw==",
+      "license": "MIT",
+      "dependencies": {
+        "is-map": "^2.0.3",
+        "is-set": "^2.0.3",
+        "is-weakmap": "^2.0.2",
+        "is-weakset": "^2.0.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/which-typed-array": {
+      "version": "1.1.19",
+      "resolved": "https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.19.tgz",
+      "integrity": "sha512-rEvr90Bck4WZt9HHFC4DJMsjvu7x+r6bImz0/BrbWb7A2djJ8hnZMrWnHo9F8ssv0OMErasDhftrfROTyqSDrw==",
+      "license": "MIT",
+      "dependencies": {
+        "available-typed-arrays": "^1.0.7",
+        "call-bind": "^1.0.8",
+        "call-bound": "^1.0.4",
+        "for-each": "^0.3.5",
+        "get-proto": "^1.0.1",
+        "gopd": "^1.2.0",
+        "has-tostringtag": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
     }
   }
 }
diff --git a/printer_backend/package.json b/printer_backend/package.json
index 164442a..ebb1b7c 100644
--- a/printer_backend/package.json
+++ b/printer_backend/package.json
@@ -5,9 +5,14 @@
   "main": "server.js",
   "license": "MIT",
   "dependencies": {
-    "express": "^4.19.2",
-    "cors": "^2.8.5",
     "body-parser": "^1.20.2",
-    "pdf-to-printer": "^5.0.0"
+    "cors": "^2.8.5",
+    "express": "^4.19.2",
+  "express-fileupload": "^1.5.2",
+  "pdf-to-printer": "^5.0.0",
+  "pdfkit": "^0.15.0"
+  },
+  "scripts": {
+    "start": "node server.js"
   }
 }
diff --git a/printer_backend/server.js b/printer_backend/server.js
index 5f27c50..f7be385 100644
--- a/printer_backend/server.js
+++ b/printer_backend/server.js
@@ -1,31 +1,130 @@
 import express from 'express';
 import cors from 'cors';
 import bodyParser from 'body-parser';
-import { getPrinters, print } from 'pdf-to-printer';
 import fileUpload from 'express-fileupload';
 import fs from 'fs';
 import path from 'path';
+import * as cp from 'child_process';
+import { execFile } from 'child_process';
+import PDFDocument from 'pdfkit';
+
+// NOTE: We no longer attempt to monkey-patch child_process methods on ESM modules
+// because module namespace objects are read-only in Node >= 14+, which caused
+// "Cannot assign to read only property 'spawn'" errors. We rely on pdf-to-printer
+// defaults and set windowsHide in our own exec wrappers where applicable.
+
+// Dynamically import pdf-to-printer AFTER patching child_process
+const ptp = await import('pdf-to-printer');
+const mod = ptp.default || ptp; // ESM/CJS compatibility
+const getPrinters = mod.getPrinters;
+const print = mod.print;
+// moved imports earlier
 
 const app = express();
 app.use(cors());
 app.use(bodyParser.json({ limit: '5mb' }));
 app.use(fileUpload());
 
+// Simple healthcheck for connectivity debugging
+app.get('/health', (req,res)=> res.json({ ok: true }));
+
+// Diagnostics endpoint to inspect runtime flags (avoid sensitive data)
+app.get('/diagnostics', (req,res)=>{
+  res.json({
+    platform: process.platform,
+    useRaw: process.env.USE_SIMPLE_PRINT === '1' || process.env.USE_RAW_PRINT === '1',
+    nodeVersion: process.version,
+    pid: process.pid,
+    cwd: process.cwd()
+  });
+});
+
+app.get('/logs', (req,res)=>{
+  try {
+    const logPath = path.join(process.cwd(), 'print_backend.log');
+    if (!fs.existsSync(logPath)) return res.json({ log: '' });
+    const content = fs.readFileSync(logPath, 'utf8');
+    const maxLen = 2000;
+    const tail = content.length > maxLen ? content.slice(-maxLen) : content;
+    res.json({ log: tail });
+  } catch (e) {
+    res.status(500).json({ error: String(e) });
+  }
+});
+
+// Enumerate printers explicitly (for debugging a failing silent print). Safe to call manually.
+app.get('/debug-printers', async (req,res)=>{
+  try {
+    const printersRaw = await getPrinters();
+    const names = Array.isArray(printersRaw)
+      ? printersRaw.map(p => (p && p.name) ? p.name : (typeof p === 'string' ? p : '')).filter(Boolean)
+      : [];
+    logToFile('DEBUG_PRINTERS names=' + JSON.stringify(names));
+    res.json({ printers: names });
+  } catch (e) {
+    logToFile('DEBUG_PRINTERS_ERROR: ' + e);
+    res.status(500).json({ error: String(e) });
+  }
+});
+
 const CONFIG_PATH = path.join(process.cwd(), 'config.json');
 function loadConfig() {
-  try { return JSON.parse(fs.readFileSync(CONFIG_PATH,'utf8')); } catch { return { defaultPrinter: null, settings: {} }; }
+  try {
+    const cfg = JSON.parse(fs.readFileSync(CONFIG_PATH,'utf8'));
+    if (!('rawShare' in cfg)) cfg.rawShare = null; // augment existing configs
+    if (!('settings' in cfg)) cfg.settings = {};
+    return cfg;
+  } catch {
+    return { defaultPrinter: null, settings: {}, rawShare: null };
+  }
 }
 function saveConfig(cfg) { fs.writeFileSync(CONFIG_PATH, JSON.stringify(cfg, null, 2)); }
 
+// Attempt to assign a default thermal printer automatically if none is set.
+async function autoAssignDefaultPrinter(cfg) {
+  if (cfg.defaultPrinter) return cfg; // already set
+  try {
+    const printers = await getPrinters();
+    if (!Array.isArray(printers) || printers.length === 0) return cfg;
+    // Extract names (support objects or plain strings)
+    const names = printers.map(p => typeof p === 'string' ? p : (p && p.name) ? p.name : '').filter(Boolean);
+    if (names.length === 1) {
+      cfg.defaultPrinter = names[0];
+      saveConfig(cfg);
+      logToFile(`AUTO_PRINTER_SINGLE: set defaultPrinter='${cfg.defaultPrinter}'`);
+      return cfg;
+    }
+    const patterns = [
+      /^pos ?58(?:\(2\))?$/i,
+      /pos[- ]?58/i,
+      /58mm/i,
+    ];
+    for (const pat of patterns) {
+      const match = names.find(n => pat.test(n));
+      if (match) {
+        cfg.defaultPrinter = match;
+        saveConfig(cfg);
+        logToFile(`AUTO_PRINTER_PATTERN: set defaultPrinter='${cfg.defaultPrinter}' using pattern ${pat}`);
+        return cfg;
+      }
+    }
+  } catch (e) {
+    logToFile('AUTO_PRINTER_ERROR: ' + e);
+  }
+  return cfg;
+}
+
 // Get config
 app.get('/config', (req,res)=>{ res.json(loadConfig()); });
 
 // List printers
 app.get('/printers', async (req, res) => {
   try {
-    const printers = await getPrinters();
-    res.json({ printers });
+    const names = await listPrintersSafe();
+    // Return in a consistent shape
+    res.json({ printers: names.map(n => ({ name: n })) });
   } catch (e) {
+    console.error('GET /printers error:', e);
     res.status(500).json({ error: String(e) });
   }
 });
@@ -35,26 +134,62 @@ app.post('/print-text', async (req, res) => {
   const { printer, text, settings } = req.body || {};
   if (!text) return res.status(400).json({ error: 'text required' });
   const cfg = loadConfig();
-  const targetPrinter = printer || cfg.defaultPrinter || undefined;
+  let targetPrinter = printer || cfg.defaultPrinter || undefined;
+  if (!targetPrinter) {
+    try {
+      const names = await listPrintersSafe();
+      if (names.length === 1) {
+        targetPrinter = names.first ? names[0] : names[0];
+      } else if (names.length === 0) {
+        return res.status(400).json({ error: 'No printers found. Please install or configure a default printer.' });
+      } else {
+        return res.status(400).json({ error: 'No default printer configured. Use /set-default or set config.json defaultPrinter.', availablePrinters: names });
+      }
+    } catch (e) {
+      return res.status(500).json({ error: 'Unable to determine printers: ' + e });
+    }
+  }
   try {
+    // Skipping live printer validation to avoid spawning PowerShell/console windows on each print.
     const tempFile = path.join(process.cwd(), 'temp_print.txt');
     fs.writeFileSync(tempFile, text, 'utf8');
-    await print(tempFile, targetPrinter ? { printer: targetPrinter } : undefined);
+    const opts = buildPrintOptions(targetPrinter, settings || cfg.settings);
+    await print(tempFile, opts);
     res.json({ status: 'ok', usedPrinter: targetPrinter || 'system-default' });
   } catch (e) {
-    res.status(500).json({ error: String(e) });
+    console.error('POST /print-text error:', e);
+    res.status(500).json({ error: String(e), usedPrinter: targetPrinter || 'system-default' });
   }
 });
 
 // Save defaults
-app.post('/set-default', (req,res)=>{
+app.post('/set-default', async (req,res)=>{
   const { printer, settings } = req.body || {};
   if (!printer) return res.status(400).json({ error: 'printer required' });
+  try {
+    const names = await listPrintersSafe();
+    if (!names.includes(printer)) {
+      return res.status(400).json({ error: `Printer '${printer}' not found`, availablePrinters: names });
+    }
+    const cfg = loadConfig();
+    cfg.defaultPrinter = printer;
+    cfg.settings = settings || {};
+    saveConfig(cfg);
+    res.json({ status:'ok' });
+  } catch (e) {
+    console.error('POST /set-default error:', e);
+    res.status(500).json({ error: String(e) });
+  }
+});
+
+// Set or clear raw share name for ESC/POS fallback (Windows printer sharing name)
+app.post('/set-raw-share', (req,res)=>{
+  const { share } = req.body || {};
   const cfg = loadConfig();
-  cfg.defaultPrinter = printer;
-  cfg.settings = settings || {};
+  cfg.rawShare = share || null;
   saveConfig(cfg);
-  res.json({ status:'ok' });
+  logToFile('SET_RAW_SHARE share=' + (cfg.rawShare || 'null'));
+  res.json({ status: 'ok', rawShare: cfg.rawShare });
 });
 
 // Print PDF upload
@@ -65,15 +200,310 @@ app.post('/print-pdf', async (req,res)=>{
   const f = req.files.file;
   const tempPath = path.join(process.cwd(), 'upload_'+Date.now()+'.pdf');
   try {
+    // Skip validation to keep operation silent (no PowerShell window for enumeration).
     await f.mv(tempPath);
-    await print(tempPath, printer ? { printer } : undefined);
+    const opts = buildPrintOptions(printer, cfg.settings);
+    await print(tempPath, opts);
     res.json({ status:'ok', usedPrinter: printer || 'system-default' });
   } catch (e) {
-    res.status(500).json({ error: String(e) });
+    console.error('POST /print-pdf error:', e);
+    res.status(500).json({ error: String(e), usedPrinter: printer || 'system-default' });
   } finally {
     setTimeout(()=>{ try { fs.unlinkSync(tempPath); } catch {} }, 5000);
   }
 });
 
+// Print invoice directly from JSON payload (server builds 48mm thermal style PDF)
+// Payload: { invoice: { invoiceNumber, timestamp, customerName, lines:[{name,qty,unitPrice,tax,lineTotal}], subtotal, discountTotal, taxTotal, grandTotal, taxesByRate } }
+app.post('/print-invoice', async (req, res) => {
+  try {
+    const { invoice } = req.body || {};
+    if (!invoice) return res.status(400).json({ error: 'invoice object required' });
+    if (!Array.isArray(invoice.lines) || invoice.lines.length === 0) {
+      return res.status(400).json({ error: 'invoice.lines required' });
+    }
+    let cfg = loadConfig();
+    cfg = await autoAssignDefaultPrinter(cfg);
+    let printer = cfg.defaultPrinter;
+    if (!printer) {
+      try {
+        const names = await getPrinters();
+        if (Array.isArray(names) && names.length === 1 && names[0] && names[0].name) {
+          printer = names[0].name; // auto adopt the single printer
+        } else if (!names || names.length === 0) {
+          return res.status(400).json({ error: 'No printers detected. Install a printer or configure defaultPrinter in config.json.' });
+        } else {
+          return res.status(400).json({ error: 'Multiple printers found; set defaultPrinter via /set-default.', availablePrinters: names.map(p=>p.name).filter(Boolean) });
+        }
+      } catch (e) {
+        return res.status(500).json({ error: 'Printer enumeration failed: ' + e });
+      }
+    }
+    // Skip validation to avoid PowerShell enumeration when printing; rely on spooler failure if invalid.
+    // Build PDF into buffer
+    const pdfPath = path.join(process.cwd(), `inv_${Date.now()}.pdf`);
+    await buildThermalInvoicePdf(invoice, pdfPath);
+    // Raw PowerShell fallback removed to prevent any visible window. Rely solely on pdf-to-printer.
+    if (process.env.PRINT_VERBOSE === '1') {
+      try {
+        const dbgPrinters = await getPrinters();
+        logToFile('VERBOSE_PRINTERS: ' + JSON.stringify(dbgPrinters));
+      } catch (e) {
+        logToFile('VERBOSE_PRINTERS_ERROR: ' + e);
+      }
+    }
+    const opts = buildPrintOptions(printer, cfg.settings);
+    try {
+      const st = fs.statSync(pdfPath);
+      logToFile(`PRINT_INVOICE_FILE_READY path=${pdfPath} size=${st.size}`);
+    } catch (e) {
+      logToFile(`PRINT_INVOICE_FILE_STAT_ERROR path=${pdfPath} err=${e}`);
+    }
+    logToFile(`PRINT_INVOICE_ATTEMPT file=${pdfPath} printer=${printer || 'system-default'} opts=${JSON.stringify(opts)}`);
+    try {
+      const delayMs = Number(process.env.PRINT_DELAY_MS || '0');
+      if (delayMs > 0) {
+        await new Promise(r => setTimeout(r, delayMs));
+        logToFile('PRINT_INVOICE_DELAY_APPLIED ms=' + delayMs);
+      }
+      await print(pdfPath, opts);
+      logToFile('PRINT_INVOICE_SUCCESS printer=' + (printer || 'system-default'));
+      res.json({ status: 'ok', message: 'Invoice print sent', usedPrinter: printer || 'system-default' });
+    } catch (err) {
+      let errLine = 'PRINT_INVOICE_LIB_ERROR:';
+      if (err && err.message) errLine += ' message=' + err.message.replace(/\s+/g,' ');
+      if (err && err.code) errLine += ' code=' + err.code;
+      if (err && err.stderr) errLine += ' stderr=' + String(err.stderr).trim();
+      if (err && err.stdout) errLine += ' stdout=' + String(err.stdout).trim();
+      errLine += ' full=' + (err && err.stack ? err.stack.split('\n')[0] : String(err));
+      logToFile(errLine);
+      // Additional diagnostic: attempt one enumeration after failure (still hidden)
+      try {
+        const afterPrinters = await getPrinters();
+        logToFile('PRINT_INVOICE_AFTER_FAIL_PRINTERS: ' + JSON.stringify(afterPrinters));
+      } catch (e2) {
+        logToFile('PRINT_INVOICE_AFTER_FAIL_ENUM_ERROR: ' + e2);
+      }
+      // Attempt fallback plain text print (best effort) if on Windows
+      if (process.platform === 'win32') {
+        try {
+          const txtPath = path.join(process.cwd(), `inv_${Date.now()}.txt`);
+          fs.writeFileSync(txtPath, buildPlainTextInvoice(invoice), 'utf8');
+          logToFile('PRINT_INVOICE_FALLBACK_TXT_ATTEMPT file=' + txtPath);
+          const winPrinterArg = `/D:${(printer || '').replace(/\s+/g,' ')}`; // print cmd cannot handle quoted printer inside /D:
+          // Use legacy print command; returns stdout/stderr we log.
+          const result = await execFileP('cmd.exe', ['/c', 'print', winPrinterArg, txtPath]);
+          logToFile('PRINT_INVOICE_FALLBACK_TXT_RESULT stdout=' + result.stdout.trim().replace(/\s+/g,' ') + ' stderr=' + result.stderr.trim().replace(/\s+/g,' '));
+          logToFile('PRINT_INVOICE_FALLBACK_TXT_SUCCESS printer=' + (printer || 'system-default'));
+          setTimeout(()=>{ try { fs.unlinkSync(txtPath); } catch {} }, 4000);
+          return res.json({ status: 'ok', message: 'Invoice print sent (txt fallback)', usedPrinter: printer || 'system-default', fallback: 'text' });
+        } catch (fe) {
+          logToFile('PRINT_INVOICE_FALLBACK_TXT_ERROR: ' + fe);
+          // If text fallback failed AND a raw share is configured attempt ESC/POS share fallback
+          try {
+            const cfg2 = loadConfig();
+            if (cfg2.rawShare) {
+              const escPath = path.join(process.cwd(), `inv_${Date.now()}.esc`);
+              const escBuf = buildEscPosReceipt(invoice);
+              fs.writeFileSync(escPath, escBuf);
+              logToFile('PRINT_INVOICE_FALLBACK_ESC_ATTEMPT file=' + escPath + ' share=' + cfg2.rawShare);
+              // type binary may corrupt if codepage mismatch; most ESC/POS accepts ASCII here; use /c cmd copy
+              const sharePath = `\\\\localhost\\${cfg2.rawShare}`;
+              // Using powershell might reveal window; keep with cmd copy
+              const escResult = await execFileP('cmd.exe', ['/c', 'copy', '/b', escPath, sharePath]);
+              logToFile('PRINT_INVOICE_FALLBACK_ESC_RESULT stdout=' + escResult.stdout.trim().replace(/\s+/g,' ') + ' stderr=' + escResult.stderr.trim().replace(/\s+/g,' '));
+              logToFile('PRINT_INVOICE_FALLBACK_ESC_SUCCESS share=' + cfg2.rawShare);
+              setTimeout(()=>{ try { fs.unlinkSync(escPath); } catch {} }, 4000);
+              return res.json({ status: 'ok', message: 'Invoice print sent (ESC fallback)', usedPrinter: printer || 'system-default', fallback: 'escpos' });
+            } else {
+              logToFile('PRINT_INVOICE_FALLBACK_ESC_SKIPPED no rawShare configured');
+            }
+          } catch (escErr) {
+            logToFile('PRINT_INVOICE_FALLBACK_ESC_ERROR: ' + escErr);
+          }
+        }
+      }
+      throw err; // bubble original error if fallback failed
+    }
+    setTimeout(()=>{ try { fs.unlinkSync(pdfPath); } catch {} }, 5000);
+  } catch (e) {
+    logToFile('PRINT_INVOICE_ERROR: ' + (e && e.stack ? e.stack : String(e)));
+    console.error('POST /print-invoice error:', e);
+    res.status(500).json({ error: String(e) });
+  }
+});
+
 const PORT = process.env.PORT || 5005;
 app.listen(PORT, () => console.log('Printer backend listening on ' + PORT));
+
+// Helpers
+function buildPrintOptions(printer, settings) {
+  const opts = {};
+  if (printer) opts.printer = String(printer);
+  // Keep only safe options to avoid library regex on undefined values
+  if (settings && typeof settings.monochrome === 'boolean') {
+    opts.monochrome = settings.monochrome;
+  }
+  return opts;
+}
+
+// ---- Helpers: safe printer listing with Windows fallback ----
+function execFileP(file, args, options) {
+  return new Promise((resolve, reject) => {
+    execFile(file, args, options, (err, stdout, stderr) => {
+      if (err) return reject(err);
+      resolve({ stdout, stderr });
+    });
+  });
+}
+
+async function listPrintersSafe() {
+  try {
+    const printers = await getPrinters();
+    // Some environments return undefined properties; map defensively
+    const names = Array.isArray(printers) ? printers.map(p => (p && p.name ? String(p.name) : '')).filter(Boolean) : [];
+    return names; // No PowerShell fallback to avoid any visible windows.
+  } catch (e) {
+    throw e;
+  }
+}
+
+// ----- PDF Generation (48mm thermal style) -----
+function buildThermalInvoicePdf(invoice, outPath) {
+  return new Promise((resolve, reject) => {
+    try {
+      const widthPts = (48/25.4)*72; // 48mm in PDF points
+      // Estimate dynamic height based on number of lines to avoid excessive blank space or truncation.
+      const lineCount = (() => {
+        let base = 5; // title + number + timestamp + customer + first separator
+        const itemLines = Array.isArray(invoice.lines) ? invoice.lines.length * 2 : 0; // name + qty line
+        let totals = 6; // subtotal, discount (maybe), tax, total, thank you, spacing
+        if (!invoice.discountTotal) totals -= 1; // remove discount line if none
+        return base + itemLines + totals + 4; // extra spacing lines
+      })();
+      const estHeight = Math.max(300, lineCount * 12); // 12pt per line approx
+      const doc = new PDFDocument({ size: [ widthPts, estHeight ], margin: 6 });
+      const stream = fs.createWriteStream(outPath);
+      doc.pipe(stream);
+      const fontSizeSmall = 8;
+      const fontSizeNormal = 9;
+      const fontSizeTitle = 12;
+      doc.fontSize(fontSizeTitle).text('INVOICE', { align: 'center' });
+      if (invoice.invoiceNumber) doc.fontSize(fontSizeSmall).text(invoice.invoiceNumber, { align: 'center' });
+      if (invoice.timestamp) doc.fontSize(fontSizeSmall).text(invoice.timestamp.toString(), { align: 'center' });
+      doc.moveDown(0.3);
+      if (invoice.customerName) doc.fontSize(fontSizeNormal).text(invoice.customerName, { align: 'center' });
+      doc.moveDown(0.4);
+      doc.moveTo(doc.x, doc.y).lineTo((48/25.4)*72 - 6*2, doc.y).stroke();
+      doc.moveDown(0.2);
+      // Lines
+      invoice.lines.forEach(l => {
+        const qty = l.qty ?? 1;
+        const price = Number(l.unitPrice || 0).toFixed(2);
+        const total = Number(l.lineTotal || 0).toFixed(2);
+        const name = (l.name || '').toString();
+        doc.fontSize(fontSizeSmall).text(name, { width: (48/25.4)*72 - 12 });
+        doc.fontSize(fontSizeSmall).text(`${qty} x ${price} = ${total}`);
+      });
+      doc.moveDown(0.2);
+      doc.moveTo(doc.x, doc.y).lineTo((48/25.4)*72 - 6*2, doc.y).stroke();
+      doc.moveDown(0.2);
+      // Totals
+      const subtotal = Number(invoice.subtotal || 0).toFixed(2);
+      const discount = Number(invoice.discountTotal || 0).toFixed(2);
+      const tax = Number(invoice.taxTotal || 0).toFixed(2);
+      const grand = Number(invoice.grandTotal || 0).toFixed(2);
+      doc.fontSize(fontSizeSmall).text(`Subtotal: ${subtotal}`);
+      if (invoice.discountTotal) doc.fontSize(fontSizeSmall).text(`Discount: -${discount}`);
+      doc.fontSize(fontSizeSmall).text(`Tax: ${tax}`);
+      doc.fontSize(fontSizeNormal).text(`TOTAL: ${grand}`, { align: 'right' });
+      doc.moveDown(0.4);
+      doc.fontSize(fontSizeSmall).text('Thank you!', { align: 'center' });
+      doc.end();
+      stream.on('finish', resolve);
+      stream.on('error', reject);
+    } catch (err) {
+      reject(err);
+    }
+  });
+}
+
+// --- Simple file logger (since backend may run fully hidden) ---
+function logToFile(message) {
+  try {
+    const line = `[${new Date().toISOString()}] ${message}\n`;
+    fs.appendFileSync(path.join(process.cwd(), 'print_backend.log'), line, 'utf8');
+  } catch (_) {}
+}
+
+// --- Plain text fallback builder (very compact 48mm style) ---
+function buildPlainTextInvoice(invoice) {
+  const pad = (s, w) => {
+    s = String(s); return s.length >= w ? s.slice(0,w) : s + ' '.repeat(w - s.length);
+  };
+  const lines = [];
+  lines.push('       INVOICE');
+  if (invoice.invoiceNumber) lines.push(String(invoice.invoiceNumber));
+  if (invoice.timestamp) lines.push(String(invoice.timestamp));
+  if (invoice.customerName) lines.push(invoice.customerName);
+  lines.push('------------------------------');
+  (invoice.lines || []).forEach(l => {
+    const name = (l.name || '').toString();
+    const qty = l.qty || 1; const price = Number(l.unitPrice||0).toFixed(2); const tot = Number(l.lineTotal||0).toFixed(2);
+    lines.push(name);
+    lines.push(`${qty} x ${price} = ${tot}`);
+  });
+  lines.push('------------------------------');
+  const subtotal = Number(invoice.subtotal||0).toFixed(2);
+  const discount = Number(invoice.discountTotal||0).toFixed(2);
+  const tax = Number(invoice.taxTotal||0).toFixed(2);
+  const grand = Number(invoice.grandTotal||0).toFixed(2);
+  lines.push(`Subtotal: ${subtotal}`);
+  if (invoice.discountTotal) lines.push(`Discount: -${discount}`);
+  lines.push(`Tax: ${tax}`);
+  lines.push(`TOTAL: ${grand}`);
+  lines.push('');
+  lines.push('  Thank you!');
+  return lines.join('\r\n');
+}
+
+// --- ESC/POS fallback (very basic commands, no codepage shifting) ---
+function buildEscPosReceipt(invoice) {
+  const ESC = (s) => Buffer.from(s, 'binary');
+  const chunks = [];
+  const pushTxt = (text='') => { chunks.push(Buffer.from(text + '\n', 'ascii')); };
+  // Init
+  chunks.push(Buffer.from([0x1B,0x40])); // Initialize
+  // Center
+  chunks.push(Buffer.from([0x1B,0x61,0x01]));
+  pushTxt('INVOICE');
+  if (invoice.invoiceNumber) pushTxt(String(invoice.invoiceNumber));
+  if (invoice.timestamp) pushTxt(String(invoice.timestamp));
+  if (invoice.customerName) pushTxt(String(invoice.customerName));
+  // Left align
+  chunks.push(Buffer.from([0x1B,0x61,0x00]));
+  pushTxt('------------------------------');
+  (invoice.lines||[]).forEach(l => {
+    const name = (l.name||'').toString();
+    const qty = l.qty || 1; const price = Number(l.unitPrice||0).toFixed(2); const tot = Number(l.lineTotal||0).toFixed(2);
+    pushTxt(name);
+    pushTxt(`${qty} x ${price} = ${tot}`);
+  });
+  pushTxt('------------------------------');
+  const subtotal = Number(invoice.subtotal||0).toFixed(2);
+  const discount = Number(invoice.discountTotal||0).toFixed(2);
+  const tax = Number(invoice.taxTotal||0).toFixed(2);
+  const grand = Number(invoice.grandTotal||0).toFixed(2);
+  pushTxt(`Subtotal: ${subtotal}`);
+  if (invoice.discountTotal) pushTxt(`Discount: -${discount}`);
+  pushTxt(`Tax: ${tax}`);
+  pushTxt(`TOTAL: ${grand}`);
+  // Center thank you
+  chunks.push(Buffer.from([0x1B,0x61,0x01]));
+  pushTxt('Thank you!');
+  // Feed & cut (partial cut if supported)
+  chunks.push(Buffer.from([0x1B,0x61,0x00])); // left
+  chunks.push(Buffer.from('\n\n\n', 'ascii'));
+  chunks.push(Buffer.from([0x1D,0x56,0x42,0x10])); // GS V B 16 (partial cut some models)
+  return Buffer.concat(chunks);
+}
-- 
2.50.0.windows.2

